{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Fluxtion Server","text":"<p>Welcome to the Fluxtion Server documentation.</p> <ul> <li>Start with the Overview to learn concepts and architecture.</li> <li>See Examples for quick hands-on guidance.</li> <li>Use How-to guides for common tasks and extensions.</li> <li>Dive into Architecture and Threading model for internals.</li> </ul> <p>Quick links:</p> <ul> <li>Overview \u2192 guide/overview.md</li> <li>Threading model \u2192 guide/threading-model.md</li> <li>Architecture \u2192 architecture/index.md</li> <li>Event flow \u2192 architecture/event-flow.md</li> <li>Sequence diagrams \u2192 architecture/sequence-diagrams/index.md</li> </ul> <p>If you find an issue or want to improve the docs, click \u201cEdit this page\u201d in the top right or open a PR on GitHub.</p>"},{"location":"tasks/","title":"Fluxtion Server Improvement Tasks","text":"<p>This document contains a detailed list of actionable improvement tasks for the Fluxtion Server project. The tasks are logically ordered and cover both architectural and code-level improvements.</p>"},{"location":"tasks/#architecture-improvements","title":"Architecture Improvements","text":""},{"location":"tasks/#documentation-and-design","title":"Documentation and Design","text":"<ul> <li> Create comprehensive architecture documentation with component diagrams</li> <li> Document the event flow architecture and patterns used</li> <li> Create sequence diagrams for key operations (event subscription, event processing)</li> <li> Establish coding standards and best practices document</li> </ul>"},{"location":"tasks/#testing","title":"Testing","text":"<ul> <li> Implement comprehensive unit test suite with higher coverage</li> <li> Add integration tests for end-to-end event flow</li> <li> Create performance benchmarks for event processing</li> <li> Implement stress tests for high-volume event scenarios</li> </ul>"},{"location":"tasks/#configuration","title":"Configuration","text":"<ul> <li> Refactor configuration system to use a more type-safe approach</li> <li> Add validation for configuration parameters</li> <li> Implement hot reloading of configuration</li> <li> Create configuration templates for common use cases</li> </ul>"},{"location":"tasks/#monitoring-and-observability","title":"Monitoring and Observability","text":"<ul> <li> Implement metrics collection for event processing (throughput, latency)</li> <li> Add health check endpoints</li> <li> Enhance logging with structured logging format</li> <li> Implement distributed tracing for event flows</li> </ul>"},{"location":"tasks/#scalability-and-performance","title":"Scalability and Performance","text":"<ul> <li> Optimize event queue implementations for higher throughput</li> <li> Implement backpressure mechanisms for event sources</li> <li> Add support for distributed event processing</li> <li> Optimize memory usage in high-volume scenarios</li> </ul>"},{"location":"tasks/#code-level-improvements","title":"Code-Level Improvements","text":""},{"location":"tasks/#error-handling","title":"Error Handling","text":"<ul> <li> Implement comprehensive error handling strategy</li> <li> Add retry mechanisms for failed event processing</li> <li> Create error reporting and notification system</li> <li> Improve error logging with more context</li> </ul>"},{"location":"tasks/#code-quality","title":"Code Quality","text":"<ul> <li> Fix SuppressWarnings usage (replace with proper type safety)</li> <li> Address TODO comments in the codebase</li> <li> Implement consistent naming conventions</li> <li> Reduce code duplication in event handling logic</li> </ul>"},{"location":"tasks/#api-improvements","title":"API Improvements","text":"<ul> <li> Create a more fluent API for event subscription</li> <li> Improve service registration API</li> <li> Add builder patterns for complex configurations</li> <li> Create a more consistent exception hierarchy</li> </ul>"},{"location":"tasks/#dependency-management","title":"Dependency Management","text":"<ul> <li> Review and update external dependencies</li> <li> Reduce coupling between components</li> <li> Implement proper dependency injection</li> <li> Create clear boundaries between modules</li> </ul>"},{"location":"tasks/#security","title":"Security","text":"<ul> <li> Implement authentication and authorization for admin operations</li> <li> Add input validation for all external inputs</li> <li> Implement secure configuration handling</li> <li> Add audit logging for security-sensitive operations</li> </ul>"},{"location":"tasks/#technical-debt","title":"Technical Debt","text":""},{"location":"tasks/#code-cleanup","title":"Code Cleanup","text":"<ul> <li> Remove experimental annotations where implementation is stable</li> <li> Fix raw type usage in generics</li> <li> Address compiler warnings</li> <li> Remove unused code and dead code paths</li> </ul>"},{"location":"tasks/#refactoring","title":"Refactoring","text":"<ul> <li> Refactor EventFlowManager to reduce complexity</li> <li> Split FluxtionServer class into smaller, focused classes</li> <li> Improve thread safety in concurrent operations</li> <li> Refactor service lifecycle management</li> </ul>"},{"location":"tasks/#testing-infrastructure","title":"Testing Infrastructure","text":"<ul> <li> Create test utilities for common testing scenarios</li> <li> Implement test fixtures for event processing</li> <li> Add property-based testing for event handlers</li> <li> Improve test isolation and repeatability</li> </ul>"},{"location":"tasks/#build-and-cicd","title":"Build and CI/CD","text":"<ul> <li> Enhance build scripts for different environments</li> <li> Implement automated release process</li> <li> Add static code analysis to CI pipeline</li> <li> Implement automated performance regression testing</li> </ul>"},{"location":"tasks/#feature-enhancements","title":"Feature Enhancements","text":""},{"location":"tasks/#event-processing","title":"Event Processing","text":"<ul> <li> Add support for event prioritization</li> <li> Implement event filtering capabilities</li> <li> Add event transformation pipelines</li> <li> Support for event correlation and aggregation</li> </ul>"},{"location":"tasks/#administration","title":"Administration","text":"<ul> <li> Create a web-based admin interface</li> <li> Implement more comprehensive admin commands</li> <li> Add support for remote administration</li> <li> Implement role-based access control for admin operations</li> </ul>"},{"location":"tasks/#integration","title":"Integration","text":"<ul> <li> Add adapters for common messaging systems (Kafka, RabbitMQ)</li> <li> Implement REST API for event submission</li> <li> Create client libraries for common languages</li> <li> Add support for standard protocols (MQTT, AMQP)</li> </ul>"},{"location":"tasks/#deployment","title":"Deployment","text":"<ul> <li> Create Docker containerization</li> <li> Add Kubernetes deployment templates</li> <li> Implement cloud-native features</li> <li> Support for serverless deployment models</li> </ul>"},{"location":"architecture/","title":"Fluxtion Server Architecture Documentation","text":""},{"location":"architecture/#introduction","title":"Introduction","text":"<p>This directory contains comprehensive architecture documentation for the Fluxtion Server project. The documentation is organized into several sections, each focusing on a different aspect of the architecture.</p>"},{"location":"architecture/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Architecture Overview</li> <li>High-level architecture description</li> <li>Main components and their relationships</li> <li> <p>System architecture diagrams</p> </li> <li> <p>Component Architecture</p> </li> <li>Detailed description of key components</li> <li>Component responsibilities</li> <li>Class diagrams</li> <li> <p>Component relationships</p> </li> <li> <p>Event Flow Architecture</p> </li> <li>Event flow components</li> <li>Event processing pipeline</li> <li>Subscription model</li> <li>Event types and wrapping</li> <li> <p>Queue implementation</p> </li> <li> <p>Deployment Guide</p> </li> <li>Deployment models</li> <li>Performance considerations</li> <li>High availability</li> <li>Monitoring and observability</li> <li>Security considerations</li> <li>Configuration management</li> <li>Deployment checklist</li> </ol>"},{"location":"architecture/#how-to-use-this-documentation","title":"How to Use This Documentation","text":"<ul> <li>Start with the Architecture Overview to get a high-level understanding of the system</li> <li>Dive into Component Architecture to understand the key components and their relationships</li> <li>Explore Event Flow Architecture to understand how events flow through the system</li> <li>Refer to the Deployment Guide when planning a deployment</li> </ul>"},{"location":"architecture/#diagrams","title":"Diagrams","text":"<p>The documentation includes various diagrams to help visualize the architecture:</p> <ul> <li>System architecture diagrams</li> <li>Component interaction diagrams</li> <li>Event flow diagrams</li> <li>Class diagrams</li> </ul> <p>These diagrams are provided in ASCII format for easy viewing in any text editor.</p>"},{"location":"architecture/#contributing-to-the-documentation","title":"Contributing to the Documentation","text":"<p>When contributing to this documentation, please follow these guidelines:</p> <ol> <li>Use Markdown format for all documents</li> <li>Include diagrams where appropriate</li> <li>Keep the documentation up-to-date with code changes</li> <li>Organize content logically</li> <li>Use clear and concise language</li> </ol>"},{"location":"architecture/#conclusion","title":"Conclusion","text":"<p>This architecture documentation provides a comprehensive overview of the Fluxtion Server project. It serves as a reference for developers, architects, and operators working with the system. By understanding the architecture, you can more effectively develop, extend, and maintain applications built on the Fluxtion Server framework.</p>"},{"location":"architecture/components/","title":"Fluxtion Server Component Architecture","text":""},{"location":"architecture/components/#introduction","title":"Introduction","text":"<p>This document provides a detailed description of the key components in the Fluxtion Server architecture and their relationships. Understanding these components is essential for developing, extending, and maintaining applications built on the Fluxtion Server framework.</p>"},{"location":"architecture/components/#core-components","title":"Core Components","text":""},{"location":"architecture/components/#fluxtionserver","title":"FluxtionServer","text":"<p>The FluxtionServer class is the central component that bootstraps and manages the entire system. It serves as the main controller and coordinates the interactions between all other components.</p>"},{"location":"architecture/components/#responsibilities","title":"Responsibilities:","text":"<ul> <li>Loading and applying configuration</li> <li>Managing the lifecycle of event processors and services</li> <li>Registering event sources, event processors, and services</li> <li>Coordinating the event flow through the EventFlowManager</li> </ul>"},{"location":"architecture/components/#class-diagram","title":"Class Diagram:","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            FluxtionServer             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 - flowManager: EventFlowManager       \u2502\n\u2502 - appConfig: AppConfig                \u2502\n\u2502 - composingEventProcessorAgents: Map  \u2502\n\u2502 - composingServiceAgents: Map         \u2502\n\u2502 - registeredServices: Map             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 + bootServer()                        \u2502\n\u2502 + registerEventSource()               \u2502\n\u2502 + registerService()                   \u2502\n\u2502 + registerWorkerService()             \u2502\n\u2502 + addEventProcessor()                 \u2502\n\u2502 + init()                              \u2502\n\u2502 + start()                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/components/#eventflowmanager","title":"EventFlowManager","text":"<p>The EventFlowManager is responsible for managing the flow of events between sources and processors. It acts as the central hub for event routing.</p>"},{"location":"architecture/components/#responsibilities_1","title":"Responsibilities:","text":"<ul> <li>Registering event sources and their associated queues</li> <li>Managing subscriptions between event sources and processors</li> <li>Routing events from sources to appropriate processors</li> <li>Providing the infrastructure for event flow</li> </ul>"},{"location":"architecture/components/#class-diagram_1","title":"Class Diagram:","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           EventFlowManager            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 - eventSourceToQueueMap: Map          \u2502\n\u2502 - eventSinkToQueueMap: Map            \u2502\n\u2502 - eventToInvokerFactoryMap: Map       \u2502\n\u2502 - subscriberKeyToQueueMap: Map        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 + registerEventSource()               \u2502\n\u2502 + registerEventSink()                 \u2502\n\u2502 + subscribe()                         \u2502\n\u2502 + unSubscribe()                       \u2502\n\u2502 + registerEventMapperFactory()        \u2502\n\u2502 + getMappingAgent()                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/components/#eventsource","title":"EventSource","text":"<p>The EventSource interface defines components that generate events. These can be external systems, internal timers, or other event generators.</p>"},{"location":"architecture/components/#responsibilities_2","title":"Responsibilities:","text":"<ul> <li>Generating events from various sources</li> <li>Publishing events to the event flow system</li> <li>Managing subscriptions from event processors</li> </ul>"},{"location":"architecture/components/#interface-diagram","title":"Interface Diagram:","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            EventSource&lt;T&gt;             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 + subscribe()                         \u2502\n\u2502 + unSubscribe()                       \u2502\n\u2502 + setEventToQueuePublisher()          \u2502\n\u2502 + setEventWrapStrategy()              \u2502\n\u2502 + setSlowConsumerStrategy()           \u2502\n\u2502 + setDataMapper()                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/components/#eventprocessor","title":"EventProcessor","text":"<p>Event processors consume and process events. They are managed by the ComposingEventProcessorAgent and implement business logic for handling events.</p>"},{"location":"architecture/components/#responsibilities_3","title":"Responsibilities:","text":"<ul> <li>Subscribing to event sources</li> <li>Processing events according to business logic</li> <li>Generating output or side effects</li> </ul>"},{"location":"architecture/components/#component-diagram","title":"Component Diagram:","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          StaticEventProcessor         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 + onEvent()                           \u2502\n\u2502 + init()                              \u2502\n\u2502 + tearDown()                          \u2502\n\u2502 + addEventFeed()                      \u2502\n\u2502 + registerService()                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/components/#composingeventprocessoragent","title":"ComposingEventProcessorAgent","text":"<p>The ComposingEventProcessorAgent manages a group of event processors. It handles the lifecycle of processors and routes events to them.</p>"},{"location":"architecture/components/#responsibilities_4","title":"Responsibilities:","text":"<ul> <li>Managing the lifecycle of event processors</li> <li>Routing events to appropriate processors</li> <li>Handling subscriptions to event sources</li> </ul>"},{"location":"architecture/components/#class-diagram_2","title":"Class Diagram:","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     ComposingEventProcessorAgent      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 - eventFlowManager: EventFlowManager  \u2502\n\u2502 - registeredEventProcessors: Map      \u2502\n\u2502 - queueProcessorMap: Map              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 + addNamedEventProcessor()            \u2502\n\u2502 + removeEventProcessorByName()        \u2502\n\u2502 + registerSubscriber()                \u2502\n\u2502 + subscribe()                         \u2502\n\u2502 + unSubscribe()                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/components/#abstracteventsourceservice","title":"AbstractEventSourceService","text":"<p>The AbstractEventSourceService is a base class for services that act as event sources. It provides common functionality for event source services.</p>"},{"location":"architecture/components/#responsibilities_5","title":"Responsibilities:","text":"<ul> <li>Implementing the EventSource interface</li> <li>Managing the lifecycle of the service</li> <li>Publishing events to the event flow system</li> </ul>"},{"location":"architecture/components/#class-diagram_3","title":"Class Diagram:","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     AbstractEventSourceService&lt;T&gt;     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 - name: String                        \u2502\n\u2502 - output: EventToQueuePublisher&lt;T&gt;    \u2502\n\u2502 - subscriptionKey: EventSubscriptionKey\u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 + setEventFlowManager()               \u2502\n\u2502 + init()                              \u2502\n\u2502 + subscribe()                         \u2502\n\u2502 + tearDown()                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/components/#component-relationships","title":"Component Relationships","text":""},{"location":"architecture/components/#component-interaction-diagram","title":"Component Interaction Diagram","text":"<p>The following diagram illustrates the relationships between the key components:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               \u2502     \u2502               \u2502     \u2502               \u2502\n\u2502FluxtionServer \u2502\u2500\u2500\u2500\u2500\u25b6\u2502EventFlowManager\u2500\u2500\u2500\u2500\u25b6\u2502EventSource    \u2502\n\u2502               \u2502     \u2502               \u2502     \u2502               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502                                           \u2502\n        \u2502                                           \u2502\n        \u25bc                                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               \u2502                          \u2502               \u2502\n\u2502ComposingEvent \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502EventToQueue   \u2502\n\u2502ProcessorAgent \u2502                          \u2502Publisher      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u2502\n        \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               \u2502\n\u2502EventProcessor \u2502\n\u2502               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/components/#configuration-components","title":"Configuration Components","text":""},{"location":"architecture/components/#appconfig","title":"AppConfig","text":"<p>The AppConfig class holds the configuration for the entire system. It is loaded from a YAML file and used to configure all components.</p>"},{"location":"architecture/components/#responsibilities_6","title":"Responsibilities:","text":"<ul> <li>Storing configuration for event sources, processors, and services</li> <li>Providing access to configuration parameters</li> <li>Supporting configuration updates</li> </ul>"},{"location":"architecture/components/#class-diagram_4","title":"Class Diagram:","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              AppConfig                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 - eventFeeds: List&lt;EventFeedConfig&gt;   \u2502\n\u2502 - eventSinks: List&lt;EventSinkConfig&gt;   \u2502\n\u2502 - services: List&lt;ServiceConfig&gt;       \u2502\n\u2502 - eventHandlers: List&lt;EventProcessorGroupConfig&gt;\u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 + lookupIdleStrategy()                \u2502\n\u2502 + getIdleStrategyOrDefault()          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/components/#eventprocessorconfig","title":"EventProcessorConfig","text":"<p>The EventProcessorConfig class configures individual event processors. It specifies how events are processed and what handlers are used.</p>"},{"location":"architecture/components/#responsibilities_7","title":"Responsibilities:","text":"<ul> <li>Configuring event processors</li> <li>Specifying event handlers</li> <li>Setting logging levels</li> </ul>"},{"location":"architecture/components/#class-diagram_5","title":"Class Diagram:","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502        EventProcessorConfig&lt;T&gt;        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 - eventHandler: T                     \u2502\n\u2502 - customHandler: ObjectEventHandlerNode\u2502\n\u2502 - eventHandlerBuilder: Supplier&lt;T&gt;    \u2502\n\u2502 - logLevel: LogLevel                  \u2502\n\u2502 - configMap: Map&lt;String, Object&gt;      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 + getEventHandler()                   \u2502\n\u2502 + getConfigMap()                      \u2502\n\u2502 + getConfig()                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/components/#service-components","title":"Service Components","text":""},{"location":"architecture/components/#service","title":"Service","text":"<p>The Service class represents a service in the system. Services can provide various functionalities and can be event sources, event processors, or standalone services.</p>"},{"location":"architecture/components/#responsibilities_8","title":"Responsibilities:","text":"<ul> <li>Providing functionality to the system</li> <li>Managing the lifecycle of the service</li> <li>Interacting with other components</li> </ul>"},{"location":"architecture/components/#class-diagram_6","title":"Class Diagram:","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Service&lt;T&gt;               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 - instance: T                         \u2502\n\u2502 - serviceClass: Class&lt;?&gt;              \u2502\n\u2502 - serviceName: String                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 + init()                              \u2502\n\u2502 + start()                             \u2502\n\u2502 + stop()                              \u2502\n\u2502 + tearDown()                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/components/#serviceagent","title":"ServiceAgent","text":"<p>The ServiceAgent interface represents a service that runs in its own thread as an agent. It provides a way to run services in a dedicated thread.</p>"},{"location":"architecture/components/#responsibilities_9","title":"Responsibilities:","text":"<ul> <li>Running a service in a dedicated thread</li> <li>Managing the lifecycle of the service</li> <li>Interacting with other components</li> </ul>"},{"location":"architecture/components/#interface-diagram_1","title":"Interface Diagram:","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             ServiceAgent&lt;T&gt;           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 + getAgentGroup()                     \u2502\n\u2502 + getIdleStrategy()                   \u2502\n\u2502 + getService()                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/components/#conclusion","title":"Conclusion","text":"<p>The component architecture of Fluxtion Server provides a flexible and extensible framework for building event-driven applications. The clear separation of concerns between components allows for easy customization and extension, while the well-defined interfaces ensure consistent behavior across the system.</p> <p>Understanding these components and their relationships is essential for effectively using and extending the Fluxtion Server framework. This document serves as a reference for developers working with the framework, providing insights into the design and implementation of the system.</p>"},{"location":"architecture/deployment/","title":"Fluxtion Server Deployment Guide","text":""},{"location":"architecture/deployment/#introduction","title":"Introduction","text":"<p>This document provides guidance on deploying Fluxtion Server in various environments. It covers deployment considerations, performance tuning, and best practices to ensure optimal operation of Fluxtion Server applications.</p>"},{"location":"architecture/deployment/#deployment-models","title":"Deployment Models","text":"<p>Fluxtion Server can be deployed in several ways, depending on the requirements of your application:</p>"},{"location":"architecture/deployment/#standalone-application","title":"Standalone Application","text":"<p>Fluxtion Server can be deployed as a standalone Java application. This is the simplest deployment model and is suitable for many use cases.</p>"},{"location":"architecture/deployment/#configuration","title":"Configuration:","text":"<pre><code>// Load configuration from a file\nFluxtionServer server = FluxtionServer.bootServer(logRecordListener);\n\n// Or programmatically\nAppConfig appConfig = new AppConfig();\n// Configure appConfig\nFluxtionServer server = FluxtionServer.bootServer(appConfig, logRecordListener);\n</code></pre>"},{"location":"architecture/deployment/#embedded-in-another-application","title":"Embedded in Another Application","text":"<p>Fluxtion Server can be embedded within another Java application, such as a Spring Boot application or a web server.</p>"},{"location":"architecture/deployment/#configuration_1","title":"Configuration:","text":"<pre><code>// Create and configure the server\nAppConfig appConfig = new AppConfig();\n// Configure appConfig\nFluxtionServer server = new FluxtionServer(appConfig);\n\n// Register components\nserver.registerEventSource(\"source1\", eventSource);\nserver.addEventProcessor(\"processor1\", \"group1\", idleStrategy, () -&gt; eventProcessor);\n\n// Initialize and start\nserver.init();\nserver.start();\n</code></pre>"},{"location":"architecture/deployment/#containerized-deployment","title":"Containerized Deployment","text":"<p>Fluxtion Server can be deployed in containers such as Docker, which provides isolation and portability.</p>"},{"location":"architecture/deployment/#dockerfile-example","title":"Dockerfile Example:","text":"<pre><code>FROM openjdk:11-jre-slim\n\nWORKDIR /app\n\nCOPY target/fluxtion-server.jar /app/\nCOPY config/server-config.yaml /app/config/\n\nENV JAVA_OPTS=\"-Xmx2g -Xms1g\"\nENV CONFIG_FILE=\"/app/config/server-config.yaml\"\n\nCMD [\"java\", \"-jar\", \"fluxtion-server.jar\", \"-Dfluxtionserver.config.file=${CONFIG_FILE}\"]\n</code></pre>"},{"location":"architecture/deployment/#cloud-deployment","title":"Cloud Deployment","text":"<p>Fluxtion Server can be deployed to cloud environments such as AWS, Azure, or Google Cloud Platform.</p>"},{"location":"architecture/deployment/#considerations","title":"Considerations:","text":"<ul> <li>Use managed services for monitoring and logging</li> <li>Configure auto-scaling based on load</li> <li>Use cloud-native storage for persistence</li> <li>Implement proper security measures</li> </ul>"},{"location":"architecture/deployment/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/deployment/#memory-configuration","title":"Memory Configuration","text":"<p>Proper memory configuration is essential for optimal performance:</p> <pre><code>-Xmx&lt;size&gt;  # Maximum heap size\n-Xms&lt;size&gt;  # Initial heap size\n-XX:MaxMetaspaceSize=&lt;size&gt;  # Maximum metaspace size\n</code></pre> <p>Recommended settings: - Set <code>-Xms</code> and <code>-Xmx</code> to the same value to avoid heap resizing - Monitor memory usage and adjust as needed - Consider using G1GC for large heaps: <code>-XX:+UseG1GC</code></p>"},{"location":"architecture/deployment/#thread-configuration","title":"Thread Configuration","text":"<p>Fluxtion Server uses a threading model based on agents. Configure threads appropriately:</p> <pre><code>threadConfig:\n  - name: \"default\"\n    idleStrategy: \"BusySpin\"\n  - name: \"lowLatency\"\n    idleStrategy: \"BusySpin\"\n  - name: \"highThroughput\"\n    idleStrategy: \"BackOff\"\n</code></pre> <p>Considerations: - Use <code>BusySpin</code> for low-latency requirements - Use <code>BackOff</code> for high-throughput scenarios - Balance the number of threads with available CPU cores</p>"},{"location":"architecture/deployment/#queue-sizing","title":"Queue Sizing","text":"<p>Configure queue sizes based on expected load:</p> <pre><code>// In EventFlowManager.java\nnew ManyToOneConcurrentArrayQueue&lt;T&gt;(queueSize);\n</code></pre> <p>Recommendations: - Start with a queue size of 1024 or 2048 - Monitor queue overflow and adjust as needed - Consider using different queue sizes for different event types</p>"},{"location":"architecture/deployment/#high-availability","title":"High Availability","text":""},{"location":"architecture/deployment/#clustering","title":"Clustering","text":"<p>For high availability, deploy multiple instances of Fluxtion Server in a cluster:</p> <ol> <li>Active-Passive: One active instance with one or more passive instances ready to take over</li> <li>Active-Active: Multiple active instances sharing the load</li> </ol>"},{"location":"architecture/deployment/#state-replication","title":"State Replication","text":"<p>If your application maintains state, consider state replication strategies:</p> <ol> <li>Shared Database: Store state in a shared database</li> <li>Event Sourcing: Rebuild state from event logs</li> <li>State Snapshots: Periodically save and restore state snapshots</li> </ol>"},{"location":"architecture/deployment/#failover","title":"Failover","text":"<p>Implement failover mechanisms to handle instance failures:</p> <ol> <li>Health Checks: Regular health checks to detect failures</li> <li>Automatic Restart: Restart failed instances automatically</li> <li>Load Balancing: Distribute load across healthy instances</li> </ol>"},{"location":"architecture/deployment/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"architecture/deployment/#metrics-collection","title":"Metrics Collection","text":"<p>Collect metrics to monitor the health and performance of your Fluxtion Server:</p> <ol> <li>JVM Metrics: Heap usage, GC activity, thread count</li> <li>Application Metrics: Event throughput, processing latency, queue sizes</li> <li>System Metrics: CPU usage, memory usage, disk I/O, network I/O</li> </ol>"},{"location":"architecture/deployment/#logging","title":"Logging","text":"<p>Configure appropriate logging to aid in troubleshooting:</p> <pre><code>// Set log level for event processors\neventProcessor.setAuditLogLevel(EventLogControlEvent.LogLevel.INFO);\n</code></pre> <p>Recommendations: - Use structured logging for easier parsing - Configure appropriate log levels for different components - Rotate logs to manage disk space</p>"},{"location":"architecture/deployment/#distributed-tracing","title":"Distributed Tracing","text":"<p>Implement distributed tracing to track events across components:</p> <ol> <li>Trace IDs: Add trace IDs to events</li> <li>Span IDs: Create spans for different processing stages</li> <li>Visualization: Use tools like Jaeger or Zipkin to visualize traces</li> </ol>"},{"location":"architecture/deployment/#security-considerations","title":"Security Considerations","text":""},{"location":"architecture/deployment/#authentication-and-authorization","title":"Authentication and Authorization","text":"<p>Implement proper authentication and authorization:</p> <ol> <li>API Security: Secure admin APIs with authentication</li> <li>Role-Based Access: Restrict access based on roles</li> <li>Secure Communication: Use TLS for communication between components</li> </ol>"},{"location":"architecture/deployment/#data-protection","title":"Data Protection","text":"<p>Protect sensitive data:</p> <ol> <li>Encryption: Encrypt sensitive data at rest and in transit</li> <li>Data Masking: Mask sensitive data in logs</li> <li>Access Control: Restrict access to sensitive data</li> </ol>"},{"location":"architecture/deployment/#network-security","title":"Network Security","text":"<p>Secure the network:</p> <ol> <li>Firewalls: Restrict network access</li> <li>VPNs: Use VPNs for secure communication</li> <li>Network Segmentation: Isolate components in different network segments</li> </ol>"},{"location":"architecture/deployment/#configuration-management","title":"Configuration Management","text":""},{"location":"architecture/deployment/#configuration-files","title":"Configuration Files","text":"<p>Manage configuration files effectively:</p> <ol> <li>Version Control: Store configuration files in version control</li> <li>Environment-Specific Configs: Use different configurations for different environments</li> <li>Configuration Validation: Validate configuration before deployment</li> </ol>"},{"location":"architecture/deployment/#dynamic-configuration","title":"Dynamic Configuration","text":"<p>Consider dynamic configuration for runtime changes:</p> <pre><code>// Update configuration at runtime\nConfigUpdate configUpdate = new ConfigUpdate();\nconfigUpdate.setConfigMap(newConfigMap);\neventProcessor.onEvent(configUpdate);\n</code></pre>"},{"location":"architecture/deployment/#deployment-checklist","title":"Deployment Checklist","text":"<p>Before deploying Fluxtion Server to production, ensure:</p> <ol> <li>Performance Testing: Test performance under expected load</li> <li>Security Review: Review security measures</li> <li>Monitoring Setup: Set up monitoring and alerting</li> <li>Backup Strategy: Implement backup and recovery procedures</li> <li>Documentation: Document deployment procedures and configurations</li> <li>Rollback Plan: Prepare a rollback plan in case of issues</li> </ol>"},{"location":"architecture/deployment/#conclusion","title":"Conclusion","text":"<p>Deploying Fluxtion Server requires careful consideration of various factors including performance, high availability, monitoring, and security. By following the guidelines in this document, you can ensure a successful deployment that meets your application's requirements.</p> <p>Remember that deployment is not a one-time activity but an ongoing process. Continuously monitor, evaluate, and improve your deployment to maintain optimal performance and reliability.</p>"},{"location":"architecture/event-flow/","title":"Fluxtion Server Event Flow Architecture","text":""},{"location":"architecture/event-flow/#introduction","title":"Introduction","text":"<p>The event flow architecture is a core aspect of the Fluxtion Server framework. It defines how events are generated, routed, and processed throughout the system. This document provides a detailed explanation of the event flow architecture, including the components involved and their interactions.</p>"},{"location":"architecture/event-flow/#event-flow-components","title":"Event Flow Components","text":"<p>The event flow architecture consists of the following key components:</p> <ol> <li>EventSource - Generates events from external or internal sources</li> <li>EventFlowManager - Routes events between sources and processors</li> <li>EventToQueuePublisher - Publishes events to queues</li> <li>EventQueueToEventProcessor - Consumes events from queues and forwards them to processors</li> <li>EventProcessor - Processes events according to business logic</li> </ol>"},{"location":"architecture/event-flow/#component-interaction-diagram","title":"Component Interaction Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               \u2502     \u2502             EventFlowManager              \u2502\n\u2502  EventSource  \u2502\u2500\u2500\u2500\u2500\u25b6\u2502                                           \u2502\n\u2502               \u2502     \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502  \u2502EventToQueue   \u2502\u2500\u2500\u2500\u25b6\u2502EventQueue     \u2502   \u2502\n                      \u2502  \u2502Publisher      \u2502    \u2502               \u2502   \u2502\n                      \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n                      \u2502                              \u2502            \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                     \u2502\n                                                     \u25bc\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                      \u2502      EventQueueToEventProcessor          \u2502\n                      \u2502                                          \u2502\n                      \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n                      \u2502  \u2502EventToInvoke  \u2502\u2500\u2500\u2500\u25b6\u2502EventProcessor \u2502  \u2502\n                      \u2502  \u2502Strategy       \u2502    \u2502               \u2502  \u2502\n                      \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n                      \u2502                                          \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/event-flow/#event-flow-process","title":"Event Flow Process","text":"<p>The event flow process in Fluxtion Server follows these steps:</p> <ol> <li> <p>Event Generation: An EventSource generates an event, which could be from an external system, a timer, or another internal component.</p> </li> <li> <p>Event Publication: The EventSource publishes the event to the EventFlowManager through the EventToQueuePublisher.</p> </li> <li> <p>Event Routing: The EventFlowManager routes the event to the appropriate event queues based on subscriptions.</p> </li> <li> <p>Event Consumption: The EventQueueToEventProcessor consumes events from the queue.</p> </li> <li> <p>Event Processing: The EventToInvokeStrategy determines how to invoke the EventProcessor with the event, and the EventProcessor processes the event.</p> </li> <li> <p>Result Handling: The result of the event processing may generate new events, which can be fed back into the system.</p> </li> </ol>"},{"location":"architecture/event-flow/#subscription-model","title":"Subscription Model","text":"<p>Fluxtion Server uses a subscription model to connect event sources with event processors:</p> <ol> <li> <p>EventSubscriptionKey: Identifies a subscription between an event source and a processor.</p> </li> <li> <p>Subscribe/Unsubscribe: Processors can subscribe to or unsubscribe from event sources.</p> </li> <li> <p>Callback Types: Different callback types determine how events are processed (e.g., OnEvent, custom callbacks).</p> </li> </ol>"},{"location":"architecture/event-flow/#subscription-diagram","title":"Subscription Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               \u2502  1. Register             \u2502               \u2502\n\u2502  EventSource  \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502 FluxtionServer\u2502\n\u2502               \u2502                          \u2502               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502                                          \u25b2\n        \u2502                                          \u2502\n        \u2502                                          \u2502\n        \u2502                                          \u2502\n        \u2502                                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502                                  \u2502               \u2502\n        \u2502  2. Subscribe                    \u2502 EventProcessor\u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502               \u2502\n                                           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/event-flow/#event-types-and-wrapping","title":"Event Types and Wrapping","text":"<p>Fluxtion Server supports different event wrapping strategies:</p> <ol> <li>SUBSCRIPTION_NOWRAP: Events are passed directly to subscribers without wrapping.</li> <li>SUBSCRIPTION_NAMED_EVENT: Events are wrapped with source information before passing to subscribers.</li> <li>BROADCAST_NOWRAP: Events are broadcast to all subscribers without wrapping.</li> <li>BROADCAST_NAMED_EVENT: Events are wrapped and broadcast to all subscribers.</li> </ol>"},{"location":"architecture/event-flow/#slow-consumer-handling","title":"Slow Consumer Handling","text":"<p>Fluxtion Server provides strategies for handling slow consumers:</p> <ol> <li>DISCONNECT: Disconnect slow consumers to prevent system slowdown.</li> <li>EXIT_PROCESS: Exit the process if a consumer is too slow.</li> <li>BACKOFF: Implement backoff strategies to give slow consumers time to catch up.</li> </ol>"},{"location":"architecture/event-flow/#queue-implementation","title":"Queue Implementation","text":"<p>The event queues in Fluxtion Server are implemented using:</p> <ol> <li>ManyToOneConcurrentArrayQueue: For multiple producers and a single consumer.</li> <li>OneToOneConcurrentArrayQueue: For a single producer and a single consumer.</li> </ol> <p>These queue implementations provide thread-safe communication between components running in different threads.</p>"},{"location":"architecture/event-flow/#error-handling","title":"Error Handling","text":"<p>Error handling in the event flow follows these patterns:</p> <ol> <li>Global Error Handler: Catches and handles errors at the system level.</li> <li>Retry Mechanisms: Implements exponential backoff for retrying failed operations.</li> <li>Error Events: Generates error events that can be processed by error handlers.</li> </ol>"},{"location":"architecture/event-flow/#conclusion","title":"Conclusion","text":"<p>The event flow architecture of Fluxtion Server provides a flexible and efficient mechanism for routing events between sources and processors. Its subscription-based model allows for dynamic configuration of event flows, while its queue-based implementation ensures thread-safe communication between components.</p>"},{"location":"architecture/overview/","title":"Fluxtion Server Architecture Overview","text":""},{"location":"architecture/overview/#introduction","title":"Introduction","text":"<p>Fluxtion Server is an event-driven application framework designed to process events from various sources, route them to appropriate handlers, and manage the lifecycle of event processors and services. This document provides a comprehensive overview of the Fluxtion Server architecture, including component diagrams and descriptions of key components.</p>"},{"location":"architecture/overview/#high-level-architecture","title":"High-Level Architecture","text":"<p>Fluxtion Server follows an event-driven architecture pattern where events flow from sources to processors through a managed event flow system. The architecture consists of the following main components:</p> <ol> <li>FluxtionServer - The main server class that bootstraps and manages the entire system</li> <li>EventFlowManager - Manages the flow of events between sources and processors</li> <li>EventSource - Interfaces for components that generate events</li> <li>EventProcessors - Components that process events</li> <li>Services - Various services that provide functionality to the system</li> </ol>"},{"location":"architecture/overview/#component-diagram","title":"Component Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         Fluxtion Server                             \u2502\n\u2502                                                                     \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  Event Sources\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Event Flow    \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Event         \u2502   \u2502\n\u2502  \u2502               \u2502       \u2502 Manager       \u2502      \u2502 Processors    \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502          \u25b2                       \u2502                      \u2502           \u2502\n\u2502          \u2502                       \u2502                      \u2502           \u2502\n\u2502          \u2502                       \u25bc                      \u2502           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  Services     \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2502 Configuration \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2502 Admin         \u2502   \u2502\n\u2502  \u2502               \u2502       \u2502               \u2502      \u2502 Interface     \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/overview/#key-components","title":"Key Components","text":""},{"location":"architecture/overview/#fluxtionserver","title":"FluxtionServer","text":"<p>The FluxtionServer class is the main entry point and controller for the system. It is responsible for:</p> <ul> <li>Bootstrapping the server with configuration</li> <li>Managing the lifecycle of event processors and services</li> <li>Registering event sources and services</li> <li>Coordinating the event flow</li> </ul>"},{"location":"architecture/overview/#eventflowmanager","title":"EventFlowManager","text":"<p>The EventFlowManager is responsible for managing the flow of events between sources and processors. It:</p> <ul> <li>Registers event sources</li> <li>Maps events to appropriate processors</li> <li>Manages subscriptions between event sources and processors</li> <li>Provides the infrastructure for event routing</li> </ul>"},{"location":"architecture/overview/#event-sources","title":"Event Sources","text":"<p>Event sources are components that generate events. They implement the EventSource interface and are responsible for:</p> <ul> <li>Generating events from external or internal sources</li> <li>Publishing events to the event flow system</li> <li>Managing subscriptions from event processors</li> </ul>"},{"location":"architecture/overview/#event-processors","title":"Event Processors","text":"<p>Event processors consume and process events. They are managed by the ComposingEventProcessorAgent and are responsible for:</p> <ul> <li>Subscribing to event sources</li> <li>Processing events according to business logic</li> <li>Generating output or side effects</li> </ul>"},{"location":"architecture/overview/#services","title":"Services","text":"<p>Services provide various functionalities to the system. They can be:</p> <ul> <li>Event sources that generate events</li> <li>Event processors that consume events</li> <li>Standalone services that provide utility functions</li> </ul>"},{"location":"architecture/overview/#event-flow-architecture","title":"Event Flow Architecture","text":"<p>The event flow in Fluxtion Server follows this pattern:</p> <ol> <li>Event sources generate events</li> <li>Events are published to the EventFlowManager</li> <li>EventFlowManager routes events to appropriate queues</li> <li>Event processors consume events from queues</li> <li>Event processors process events and may generate new events</li> </ol>"},{"location":"architecture/overview/#event-flow-diagram","title":"Event Flow Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Event Source \u2502\u2500\u2500\u2500\u2500\u25b6\u2502  Event Queue  \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 Event         \u2502\n\u2502               \u2502     \u2502               \u2502     \u2502 Processor     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                    \u2502\n                                                    \u2502\n                                                    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Event Source \u2502\u25c0\u2500\u2500\u2500\u2500\u2502  Event Queue  \u2502\u25c0\u2500\u2500\u2500\u2500\u2502 New Event     \u2502\n\u2502  (Output)     \u2502     \u2502  (Output)     \u2502     \u2502 Generation    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/overview/#configuration-system","title":"Configuration System","text":"<p>Fluxtion Server uses a configuration system based on YAML files. The configuration defines:</p> <ul> <li>Event sources and their properties</li> <li>Event processors and their grouping</li> <li>Services and their configuration</li> <li>Threading and performance settings</li> </ul>"},{"location":"architecture/overview/#lifecycle-management","title":"Lifecycle Management","text":"<p>Fluxtion Server manages the lifecycle of components through these phases:</p> <ol> <li>Initialization - Components are created and initialized</li> <li>Start - Components are started and begin processing</li> <li>Running - Normal operation where events are processed</li> <li>Stop - Components are gracefully stopped</li> <li>Teardown - Resources are released</li> </ol>"},{"location":"architecture/overview/#threading-model","title":"Threading Model","text":"<p>Fluxtion Server uses a threading model based on agents:</p> <ul> <li>Each event processor group runs in its own thread</li> <li>Services can run in their own threads or be hosted by agents</li> <li>Event queues provide thread-safe communication between components</li> </ul>"},{"location":"architecture/overview/#conclusion","title":"Conclusion","text":"<p>The Fluxtion Server architecture provides a flexible and scalable framework for building event-driven applications. Its component-based design allows for easy extension and customization, while the event flow management system ensures efficient routing and processing of events.</p>"},{"location":"architecture/sequence-diagrams/","title":"Fluxtion Server Sequence Diagrams","text":""},{"location":"architecture/sequence-diagrams/#introduction","title":"Introduction","text":"<p>This directory contains sequence diagrams that illustrate the key operations in the Fluxtion Server framework. Sequence diagrams are a type of UML diagram that show how objects interact in a particular scenario of a use case. They are particularly useful for understanding the dynamic behavior of a system.</p>"},{"location":"architecture/sequence-diagrams/#available-sequence-diagrams","title":"Available Sequence Diagrams","text":"<ol> <li> <p>Event Subscription - Illustrates the process by which event processors register their interest in receiving events from specific event sources.</p> </li> <li> <p>Event Processing - Shows the sequence of operations that occur when an event is generated by an event source and processed by event processors.</p> </li> </ol>"},{"location":"architecture/sequence-diagrams/#how-to-read-the-sequence-diagrams","title":"How to Read the Sequence Diagrams","text":"<p>The sequence diagrams in this directory follow a standard format:</p> <ul> <li>Time flows from top to bottom</li> <li>Objects or components are represented as vertical lifelines</li> <li>Interactions between objects are shown as horizontal arrows</li> <li>Self-calls are represented as arrows that loop back to the same lifeline</li> <li>Notes provide additional context or explanations</li> </ul>"},{"location":"architecture/sequence-diagrams/#relationship-to-other-documentation","title":"Relationship to Other Documentation","text":"<p>These sequence diagrams complement the other architecture documentation:</p> <ul> <li>Architecture Overview - Provides a high-level view of the system</li> <li>Component Architecture - Describes the key components and their relationships</li> <li>Event Flow Architecture - Explains the event flow architecture in detail</li> </ul> <p>The sequence diagrams provide a dynamic view of the system, showing how the components interact over time, while the other documentation provides a more static view of the system structure.</p>"},{"location":"architecture/sequence-diagrams/#conclusion","title":"Conclusion","text":"<p>The sequence diagrams in this directory provide a detailed view of the key operations in Fluxtion Server. They are a valuable resource for understanding how the system works and for diagnosing issues that may arise during development or operation.</p>"},{"location":"architecture/sequence-diagrams/event-processing/","title":"Event Processing Sequence Diagram","text":""},{"location":"architecture/sequence-diagrams/event-processing/#introduction","title":"Introduction","text":"<p>This document provides a detailed sequence diagram for the event processing flow in Fluxtion Server. Event processing is the sequence of operations that occur when an event is generated by an event source and processed by event processors.</p>"},{"location":"architecture/sequence-diagrams/event-processing/#components-involved","title":"Components Involved","text":"<p>The following components are involved in the event processing flow:</p> <ol> <li>EventSource - The source of events</li> <li>EventToQueuePublisher - Publishes events to queues</li> <li>EventQueueToEventProcessorAgent - Consumes events from queues</li> <li>EventToInvokeStrategy - Determines how to invoke callbacks on processors</li> <li>EventProcessor - Processes events according to business logic</li> </ol>"},{"location":"architecture/sequence-diagrams/event-processing/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502EventSource    \u2502    \u2502EventToQueue   \u2502    \u2502EventQueueTo   \u2502    \u2502EventToInvoke  \u2502    \u2502EventProcessor \u2502\n\u2502               \u2502    \u2502Publisher      \u2502    \u2502EventProcessor \u2502    \u2502Strategy       \u2502    \u2502               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502  generate event    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                  \u2502 \u2502                    \u2502                    \u2502                    \u2502\n        \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502  publish(event)    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502  map event         \u2502                    \u2502                    \u2502\n        \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                  \u2502 \u2502                    \u2502                    \u2502\n        \u2502                    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502  dispatch(event)   \u2502                    \u2502                    \u2502\n        \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                  \u2502 \u2502                    \u2502                    \u2502\n        \u2502                    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502  write to queues   \u2502                    \u2502                    \u2502\n        \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                  \u2502 \u2502                    \u2502                    \u2502\n        \u2502                    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502  doWork()          \u2502                    \u2502\n        \u2502                    \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                  \u2502 \u2502                    \u2502\n        \u2502                    \u2502                    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502  poll event        \u2502                    \u2502\n        \u2502                    \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                  \u2502 \u2502                    \u2502\n        \u2502                    \u2502                    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502  processEvent()    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502  for each processor\u2502\n        \u2502                    \u2502                    \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                  \u2502 \u2502\n        \u2502                    \u2502                    \u2502                    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502  onEvent(event)    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502  process event\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502                  \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n</code></pre>"},{"location":"architecture/sequence-diagrams/event-processing/#sequence-description","title":"Sequence Description","text":"<ol> <li>EventSource generates event:</li> <li> <p>An EventSource generates an event, which could be from an external system, a timer, or another internal component.</p> </li> <li> <p>EventSource publishes event:</p> </li> <li> <p>The EventSource calls <code>publish(event)</code> on the EventToQueuePublisher to publish the event.</p> </li> <li> <p>EventToQueuePublisher maps event:</p> </li> <li> <p>The EventToQueuePublisher applies any configured data mapping to the event.</p> </li> <li> <p>EventToQueuePublisher dispatches event:</p> </li> <li> <p>The EventToQueuePublisher calls its internal <code>dispatch(event)</code> method to prepare for writing to queues.</p> </li> <li> <p>EventToQueuePublisher writes to queues:</p> </li> <li> <p>The EventToQueuePublisher writes the event to all target queues that have subscribed to this event source.</p> </li> <li> <p>EventQueueToEventProcessorAgent does work:</p> </li> <li> <p>The EventQueueToEventProcessorAgent's <code>doWork()</code> method is called by the agent runner.</p> </li> <li> <p>EventQueueToEventProcessorAgent polls event:</p> </li> <li> <p>The EventQueueToEventProcessorAgent polls an event from its input queue.</p> </li> <li> <p>EventQueueToEventProcessorAgent processes event:</p> </li> <li> <p>The EventQueueToEventProcessorAgent calls <code>processEvent(event)</code> on the EventToInvokeStrategy.</p> </li> <li> <p>EventToInvokeStrategy invokes processors:</p> </li> <li> <p>The EventToInvokeStrategy iterates through all registered processors.</p> </li> <li> <p>EventToInvokeStrategy calls onEvent:</p> <ul> <li>For each processor, the EventToInvokeStrategy calls <code>onEvent(event)</code> to deliver the event.</li> </ul> </li> <li> <p>EventProcessor processes event:</p> <ul> <li>The EventProcessor processes the event according to its business logic.</li> <li>It may update internal state, generate new events, or perform other actions.</li> </ul> </li> <li> <p>Processing complete:</p> <ul> <li>The event processing is complete, and control returns up the call stack.</li> </ul> </li> </ol>"},{"location":"architecture/sequence-diagrams/event-processing/#conclusion","title":"Conclusion","text":"<p>The event processing flow in Fluxtion Server involves multiple components working together to deliver events from sources to processors. The sequence diagram illustrates the flow of method calls and the responsibilities of each component in the processing flow. This architecture allows for efficient and flexible event processing with clear separation of concerns.</p>"},{"location":"architecture/sequence-diagrams/event-subscription/","title":"Event Subscription Sequence Diagram","text":""},{"location":"architecture/sequence-diagrams/event-subscription/#introduction","title":"Introduction","text":"<p>This document provides a detailed sequence diagram for the event subscription process in Fluxtion Server. Event subscription is the process by which event processors register their interest in receiving events from specific event sources.</p>"},{"location":"architecture/sequence-diagrams/event-subscription/#components-involved","title":"Components Involved","text":"<p>The following components are involved in the event subscription process:</p> <ol> <li>EventProcessor - The component that wants to receive events</li> <li>ComposingEventProcessorAgent - Manages event processors and their subscriptions</li> <li>EventFlowManager - Coordinates the event flow between sources and processors</li> <li>EventSource - The source of events</li> <li>EventQueueToEventProcessor - Consumes events from queues and forwards them to processors</li> </ol>"},{"location":"architecture/sequence-diagrams/event-subscription/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502EventProcessor \u2502    \u2502ComposingEvent \u2502    \u2502EventFlow      \u2502    \u2502EventSource    \u2502    \u2502EventQueueTo   \u2502\n\u2502               \u2502    \u2502ProcessorAgent \u2502    \u2502Manager        \u2502    \u2502               \u2502    \u2502EventProcessor \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502  subscribe(key)    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502  getMappingAgent() \u2502                    \u2502                    \u2502\n        \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502  create queue      \u2502                    \u2502\n        \u2502                    \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                  \u2502 \u2502                    \u2502\n        \u2502                    \u2502                    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502  create            \u2502                    \u2502\n        \u2502                    \u2502                    \u2502  EventQueueToEventProcessor             \u2502\n        \u2502                    \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502  store mapping     \u2502                    \u2502                    \u2502\n        \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                  \u2502 \u2502                    \u2502                    \u2502\n        \u2502                    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502  registerProcessor()                    \u2502                    \u2502\n        \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502  subscribe(key)    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502  subscribe(key)    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502  store subscription\u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                  \u2502 \u2502\n        \u2502                    \u2502                    \u2502                    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n        \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                    \u2502                    \u2502                    \u2502\n        \u2502                    \u2502                    \u2502                    \u2502                    \u2502\n</code></pre>"},{"location":"architecture/sequence-diagrams/event-subscription/#sequence-description","title":"Sequence Description","text":"<ol> <li>EventProcessor initiates subscription:</li> <li> <p>The EventProcessor calls <code>subscribe(subscriptionKey)</code> on the ComposingEventProcessorAgent to express interest in events from a specific source.</p> </li> <li> <p>ComposingEventProcessorAgent gets mapping agent:</p> </li> <li> <p>The ComposingEventProcessorAgent calls <code>getMappingAgent(subscriptionKey, this)</code> on the EventFlowManager to get or create an EventQueueToEventProcessor for the subscription.</p> </li> <li> <p>EventFlowManager creates queue and mapping agent:</p> </li> <li>The EventFlowManager creates a queue for the subscription if one doesn't exist.</li> <li>It creates an EventQueueToEventProcessor that will consume events from the queue and forward them to processors.</li> <li> <p>It returns the EventQueueToEventProcessor to the ComposingEventProcessorAgent.</p> </li> <li> <p>ComposingEventProcessorAgent stores mapping:</p> </li> <li> <p>The ComposingEventProcessorAgent stores the mapping between the subscription key and the EventQueueToEventProcessor.</p> </li> <li> <p>ComposingEventProcessorAgent registers processor:</p> </li> <li> <p>The ComposingEventProcessorAgent calls <code>registerProcessor(eventProcessor)</code> on the EventQueueToEventProcessor to register the EventProcessor as a listener.</p> </li> <li> <p>ComposingEventProcessorAgent subscribes to event source:</p> </li> <li> <p>The ComposingEventProcessorAgent calls <code>subscribe(subscriptionKey)</code> on the EventFlowManager to subscribe to the event source.</p> </li> <li> <p>EventFlowManager subscribes to event source:</p> </li> <li> <p>The EventFlowManager calls <code>subscribe(subscriptionKey)</code> on the EventSource to subscribe to events.</p> </li> <li> <p>EventSource stores subscription:</p> </li> <li> <p>The EventSource stores the subscription information.</p> </li> <li> <p>Subscription complete:</p> </li> <li>The subscription process is complete, and the EventProcessor will now receive events from the EventSource.</li> </ol>"},{"location":"architecture/sequence-diagrams/event-subscription/#conclusion","title":"Conclusion","text":"<p>The event subscription process in Fluxtion Server involves multiple components working together to establish a connection between event sources and event processors. The sequence diagram illustrates the flow of method calls and the responsibilities of each component in the subscription process.</p>"},{"location":"guide/file-and-memory-feeds-example/","title":"Example: Wiring File and In\u2011Memory Event Sources to a File Sink using AppConfig (Fluent API)","text":"<p>This guide shows how to:</p> <ul> <li>Extend ObjectEventHandlerNode to build a simple processor that receives all events.</li> <li>Configure two event sources: FileEventSource and InMemoryEventSource.</li> <li>Configure a FileMessageSink as an output.</li> <li>Bind everything together with the fluent AppConfig builder.</li> </ul> <p>The processor receives events from both sources and writes them to a file sink.</p>"},{"location":"guide/file-and-memory-feeds-example/#1-create-a-custom-handler","title":"1) Create a custom handler","text":"<p>Extend ObjectEventHandlerNode and inject the FileMessageSink using @ServiceRegistered, see BuilderApiExampleHandler. In handleEvent, forward the incoming event to the sink:</p> <pre><code>public class BuilderApiExampleHandler extends ObjectEventHandlerNode {\n\n    private MessageSink fileSink;\n\n    @ServiceRegistered\n    public void wire(MessageSink fileSink, String name) {\n        this.fileSink = fileSink;\n    }\n\n    @Override\n    protected boolean handleEvent(Object event) {\n        if (fileSink != null &amp;&amp; event != null) {\n            fileSink.accept(event.toString());\n        }\n        return true;\n    }\n}\n</code></pre> <p>Notes:</p> <ul> <li>FileMessageSink extends AbstractMessageSink and provides accept(value) for publishing.</li> <li>The sink is injected automatically by the server when registered as a service.</li> </ul>"},{"location":"guide/file-and-memory-feeds-example/#2-configure-sources-processor-and-sink-via-appconfig","title":"2) Configure sources, processor, and sink via AppConfig","text":"<p>Use the builder APIs for EventFeedConfig, EventProcessorGroupConfig, and register the sink as a service.</p> <pre><code>Path inputFile = Paths.get(\"/path/to/input/events.txt\");\nPath outputFile = Paths.get(\"/path/to/output/out.log\");\n\nFileMessageSink fileSink = new FileMessageSink();\nfileSink.setFilename(outputFile.toString());\n\nFileEventSource fileSource = new FileEventSource();\nfileSource.setFilename(inputFile.toString());\nfileSource.setCacheEventLog(true);\n\nInMemoryEventSource&lt;String&gt; inMemSource = new InMemoryEventSource&lt;&gt;();\ninMemSource.setCacheEventLog(true);\n\nEventProcessorGroupConfig processorGroup = EventProcessorGroupConfig.builder()\n        .agentName(\"processor-agent\")\n        .put(\"example-processor\", new EventProcessorConfig(new BuilderApiExampleHandler()))\n        .build();\n\nEventFeedConfig&lt;?&gt; fileFeedCfg = EventFeedConfig.builder()\n        .instance(fileSource)\n        .name(\"fileFeed\")\n        .broadcast(true)\n        .agent(\"file-source-agent\", new BusySpinIdleStrategy())\n        .build();\n\nEventFeedConfig&lt;?&gt; memFeedCfg = EventFeedConfig.builder()\n        .instance(inMemSource)\n        .name(\"inMemFeed\")\n        .broadcast(true)\n        .agent(\"memory-source-agent\", new BusySpinIdleStrategy())\n        .build();\n\nEventSinkConfig&lt;FileMessageSink&gt; sinkCfg = EventSinkConfig.&lt;FileMessageSink&gt;builder()\n        .instance(fileSink)\n        .name(\"fileSink\")\n        .build();\n\nAppConfig appConfig = AppConfig.builder()\n        .addProcessorGroup(processorGroup)\n        .addEventFeed(fileFeedCfg)\n        .addEventFeed(memFeedCfg)\n        .addEventSink(sinkCfg)\n        .build();\n</code></pre>"},{"location":"guide/file-and-memory-feeds-example/#3-boot-the-server-and-send-events","title":"3) Boot the server and send events","text":"<pre><code>FluxtionServer server = FluxtionServer.bootServer(appConfig, rec -&gt; {});\n\ntry {\n    // Stimulate sources: write to input file and offer memory events\n    Files.writeString(inputFile, \"file-1\\nfile-2\\n\", StandardCharsets.UTF_8);\n\n    // Access the in-memory source via registered services\n    Map&lt;String, com.fluxtion.runtime.service.Service&lt;?&gt;&gt; services = server.registeredServices();\n    @SuppressWarnings(\"unchecked\")\n    InMemoryEventSource&lt;String&gt; registeredMem = (InMemoryEventSource&lt;String&gt;) services.get(\"inMemFeed\").instance();\n    registeredMem.offer(\"mem-1\");\n    registeredMem.offer(\"mem-2\");\n\n    // Allow agents to process. Spin-wait up to a few seconds for output lines.\n    List&lt;String&gt; lines = waitForLines(outputFile, 4, 5, TimeUnit.SECONDS);\n    Assertions.assertTrue(lines.containsAll(List.of(\"file-1\", \"file-2\", \"mem-1\", \"mem-2\")),\n            () -&gt; \"Missing expected lines in sink: \" + lines);\n} finally {\n    server.stop();\n}\n</code></pre> <p>The example test BuilderApiFluentExampleTest demonstrates the complete flow and asserts that the sink contains these events from both sources:</p> <ul> <li>file-1, file-2 (from FileEventSource)</li> <li>mem-1, mem-2 (from InMemoryEventSource)</li> </ul>"},{"location":"guide/file-and-memory-feeds-example/#tips","title":"Tips","text":"<ul> <li>FileEventSource supports caching and replay across startComplete. Using setCacheEventLog(true) helps capture pre-start   data.</li> <li>InMemoryEventSource supports offer(item) and respects caching similarly.</li> <li>You can register sinks either via EventSinkConfig (when your sink type matches its generic bound) or simply as a   Service using ServiceConfig.</li> </ul>"},{"location":"guide/file-and-memory-feeds-yaml-example/","title":"Example: Wiring File and In\u2011Memory Event Sources to a File Sink using YAML configuration","text":"<p>This guide shows the same scenario as the fluent builder example, but using a YAML configuration loaded by <code>FluxtionServer.bootServer(Reader, ...)</code>.</p> <p>What you will do:</p> <ul> <li>Create a custom processor by extending <code>ObjectEventHandlerNode</code> that publishes to a file sink.</li> <li>Configure two event sources: <code>FileEventSource</code> and <code>InMemoryEventSource</code>.</li> <li>Configure a <code>FileMessageSink</code> as an output.</li> <li>Bind everything together using YAML instead of Java builder APIs.</li> </ul> <p>The processor receives events from both sources and writes them to a file sink.</p>"},{"location":"guide/file-and-memory-feeds-yaml-example/#1-custom-handler","title":"1) Custom handler","text":"<p>We reuse the same handler as the fluent example: <code>BuilderApiExampleHandler</code> \u2014 it accepts any event and publishes it to the injected sink. Source: <code>src/test/java/com/fluxtion/server/example/BuilderApiExampleHandler.java</code></p> <pre><code>public class BuilderApiExampleHandler extends ObjectEventHandlerNode {\n\n    private com.fluxtion.runtime.output.MessageSink fileSink;\n\n    @com.fluxtion.runtime.annotations.runtime.ServiceRegistered\n    public void wire(com.fluxtion.runtime.output.MessageSink fileSink, String name) {\n        this.fileSink = fileSink;\n    }\n\n    @Override\n    protected boolean handleEvent(Object event) {\n        if (fileSink != null &amp;&amp; event != null) {\n            fileSink.accept(event.toString());\n        }\n        return true;\n    }\n}\n</code></pre>"},{"location":"guide/file-and-memory-feeds-yaml-example/#2-yaml-configuration","title":"2) YAML configuration","text":"<p>The YAML wires two event feeds and one sink, and registers the handler in a processor group. Replace the file paths with your desired locations.</p> <pre><code># --------- EVENT INPUT FEEDS BEGIN CONFIG ---------\neventFeeds:\n  - instance: !!com.fluxtion.server.connector.file.FileEventSource\n      filename: /path/to/input/events.txt\n      cacheEventLog: true\n    name: fileFeed\n    agentName: file-source-agent\n    broadcast: true\n    idleStrategy: !!com.fluxtion.agrona.concurrent.BusySpinIdleStrategy { }\n  - instance: !!com.fluxtion.server.connector.memory.InMemoryEventSource { cacheEventLog: true }\n    name: inMemFeed\n    agentName: memory-source-agent\n    broadcast: true\n    idleStrategy: !!com.fluxtion.agrona.concurrent.BusySpinIdleStrategy { }\n# --------- EVENT INPUT FEEDS END CONFIG ---------\n\n# --------- EVENT SINKS BEGIN CONFIG ---------\neventSinks:\n  - instance: !!com.fluxtion.server.connector.file.FileMessageSink\n      filename: /path/to/output/out.log\n    name: fileSink\n# --------- EVENT SINKS END CONFIG ---------\n\n# --------- EVENT HANDLERS BEGIN CONFIG ---------\neventHandlers:\n  - agentName: processor-agent\n    idleStrategy: !!com.fluxtion.agrona.concurrent.BusySpinIdleStrategy { }\n    eventHandlers:\n      example-processor:\n        customHandler: !!com.fluxtion.server.example.BuilderApiExampleHandler { }\n        logLevel: INFO\n# --------- EVENT HANDLERS END CONFIG ---------\n</code></pre> <p>Notes:</p> <ul> <li><code>eventFeeds[].instance</code> holds the actual event-source object; we set properties such as <code>filename</code> and <code>cacheEventLog</code>   directly.</li> <li><code>broadcast: true</code> ensures the feed is broadcast to all processors.</li> <li>The sink is registered via <code>eventSinks</code> with an instance of <code>FileMessageSink</code> and its <code>filename</code>.</li> <li>The processor group registers <code>BuilderApiExampleHandler</code> as a <code>customHandler</code> under the name <code>example-processor</code>.</li> </ul>"},{"location":"guide/file-and-memory-feeds-yaml-example/#3-boot-the-server-and-send-events","title":"3) Boot the server and send events","text":"<pre><code>String yaml = Files.readString(Path.of(\"/path/to/config.yaml\"));\nFluxtionServer server = FluxtionServer.bootServer(new StringReader(yaml), rec -&gt; {});\n\ntry {\n    // Write file events\n    Files.writeString(Path.of(\"/path/to/input/events.txt\"), \"file-1\\nfile-2\\n\", StandardCharsets.UTF_8);\n\n    // Offer in-memory events via the registered service\n    @SuppressWarnings(\"unchecked\")\n    var inMem = (com.fluxtion.server.connector.memory.InMemoryEventSource&lt;String&gt;)\n            server.registeredServices().get(\"inMemFeed\").instance();\n    inMem.offer(\"mem-1\");\n    inMem.offer(\"mem-2\");\n\n    // Read output lines from /path/to/output/out.log and verify they include all four events\n} finally {\n    server.stop();\n}\n</code></pre>"},{"location":"guide/file-and-memory-feeds-yaml-example/#4-complete-runnable-test","title":"4) Complete, runnable test","text":"<p>See YamlConfigFeedsExampleTest for a full end-to-end test that builds the YAML string programmatically with temporary file paths, boots the server, stimulates both sources, and asserts the sink content.</p>"},{"location":"guide/file-and-memory-feeds-yaml-example/#tips","title":"Tips","text":"<ul> <li><code>FileEventSource</code> and <code>InMemoryEventSource</code> support pre-start caching via <code>cacheEventLog: true</code> so that data produced   before <code>startComplete</code> is not lost.</li> <li>You can declare additional services using <code>services:</code> in YAML if your handler needs more dependencies.</li> <li>If you want to run a sink or source on its own agent thread, ensure the instance implements</li> <li><code>com.fluxtion.agrona.concurrent.Agent</code> and add <code>agentName</code> and <code>idleStrategy</code> to the respective config section.</li> </ul>"},{"location":"guide/how-to-core-pin/","title":"How to core\u2011pin agent threads","text":"<p>This how\u2011to shows you how to pin Fluxtion Server agent threads to specific CPU cores for improved determinism and reduced context switching on supported platforms.</p> <p>What you\u2019ll do: - Configure per\u2011agent core IDs in AppConfig using the fluent builder - Understand when and how the pinning is applied at runtime - Optionally enable OS\u2011level pinning via OpenHFT Affinity - Verify and troubleshoot your setup</p> <p>Prerequisites: - Fluxtion Server 0.2.4+ (this repo) with the built\u2011in best\u2011effort pinning hook - Java 17+ - Optional: net.openhft:affinity on your classpath to perform actual OS\u2011level affinity pinning</p> <p>References in this repo: - Optional test - POM entry for optional Affinity dependency (artifact net.openhft:affinity)</p>"},{"location":"guide/how-to-core-pin/#1-configure-core-ids-with-the-fluent-appconfig-builder","title":"1) Configure core IDs with the fluent AppConfig builder","text":"<p>Pinning is configured per agent group using ThreadConfig.coreId (zero\u2011based CPU index). The server will apply the pin on the agent thread during onStart.</p> <pre><code>import com.fluxtion.agrona.concurrent.BusySpinIdleStrategy;\nimport com.fluxtion.server.config.AppConfig;\nimport com.fluxtion.server.config.ThreadConfig;\n\nAppConfig appConfig = AppConfig.builder()\n    // Processor agent group pinned to core 0\n    .addThread(ThreadConfig.builder()\n        .agentName(\"processor-agent\")\n        .idleStrategy(new BusySpinIdleStrategy())\n        .coreId(0) // zero-based index\n        .build())\n    // Service agent group pinned to core 2\n    .addThread(ThreadConfig.builder()\n        .agentName(\"service-agent\")\n        .coreId(2)\n        .build())\n    // ... add your processor groups, feeds, sinks, services\n    .build();\n</code></pre> <p>That\u2019s it for configuration. When the server boots and each agent thread starts, it will attempt to pin to the configured core.</p>"},{"location":"guide/how-to-core-pin/#2-how-it-works-at-runtime","title":"2) How it works at runtime","text":"<ul> <li>FluxtionServer resolves the configured core ID for each agent by name using resolveCoreIdForAgentName(String).</li> <li>Both agent types call the pin helper in their onStart():</li> <li>ComposingEventProcessorAgent</li> <li>ComposingServiceAgent</li> <li>Pinning is performed by CoreAffinity.pinCurrentThreadToCore(int), which uses reflection to call OpenHFT Affinity if present. If the library is not available, the helper logs an info message and no\u2011ops.</li> </ul> <p>Key code paths:</p> <ul> <li>CoreAffinity.java</li> <li>FluxtionServer.java#resolveCoreIdForAgentName</li> <li>ComposingEventProcessorAgent.java#onStart</li> <li>ComposingServiceAgent.java#onStart</li> </ul>"},{"location":"guide/how-to-core-pin/#3-enable-oslevel-pinning-optional","title":"3) Enable OS\u2011level pinning (optional)","text":"<p>To actually apply CPU affinity at the OS level, add OpenHFT Affinity to your project. This repository shows it as an optional, test\u2011scoped dependency:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;net.openhft&lt;/groupId&gt;\n  &lt;artifactId&gt;affinity&lt;/artifactId&gt;\n  &lt;version&gt;3.27ea0&lt;/version&gt;\n  &lt;scope&gt;test&lt;/scope&gt;\n  &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Notes: - You can also add it with runtime scope in your application if you want pinning in production. - Version may vary; use a version available in your repository.</p>"},{"location":"guide/how-to-core-pin/#4-verifying-pinning","title":"4) Verifying pinning","text":"<ul> <li>Quick smoke check (optional test): run CoreAffinityOptionalTest. It skips automatically if OpenHFT is not present, and passes if reflection succeeds.</li> <li>Operational verification: on Linux, you can inspect thread affinity with tools like <code>taskset -cp &lt;pid&gt;</code> or via OS perf tools, once OpenHFT Affinity is active in your runtime.</li> </ul>"},{"location":"guide/how-to-core-pin/#5-faqs-and-troubleshooting","title":"5) FAQs and troubleshooting","text":"<ul> <li>Q: What happens if I don\u2019t add OpenHFT Affinity?</li> <li> <p>A: The server logs an info message and continues without pinning. No errors are thrown.</p> </li> <li> <p>Q: What core IDs can I use?</p> </li> <li> <p>A: Core IDs are zero\u2011based and OS\u2011dependent. Ensure the indices exist on your machine. For NUMA/SMT topologies, benchmark to find the best placement.</p> </li> <li> <p>Q: Does pinning affect all agents?</p> </li> <li> <p>A: Only agents that have a matching ThreadConfig entry with a non\u2011null coreId and an agentName that matches the agent group name.</p> </li> <li> <p>Q: Any caveats?</p> </li> <li>A: Pinning may improve tail latency but can reduce the OS scheduler\u2019s flexibility. Always measure your workload.</li> </ul>"},{"location":"guide/how-to-core-pin/#6-related-reading","title":"6) Related reading","text":"<ul> <li>Threading overview and agent lifecycles</li> <li>Fluent AppConfig examples</li> </ul>"},{"location":"guide/injecting-config-into-a-processor/","title":"How to inject initial config into a processor","text":"<p>This guide shows how to inject configuration into your event processors at server boot when using the fluent AppConfig builder.</p> <p>When to use this: - Provide per-processor settings (thresholds, file names, feature flags) - Avoid global/static config and keep processor code portable</p> <p>Key pieces in this repository: - AppConfig/EventProcessorGroupConfig/EventProcessorConfig builder APIs - Config map container for type-safe lookup - Config Listener interface for receiving initial configuration - Helper wrapper: Config dispatch wrapper </p>"},{"location":"guide/injecting-config-into-a-processor/#1-how-config-is-delivered-at-boot","title":"1) How config is delivered at boot","text":"<p>During server boot, each processor is constructed and the server delivers the initial configuration to any processor that exports ConfigListener.</p> <p>Implications: - If your component (or its wrapper) implements/exports ConfigListener, it will receive the initial configuration before events start flowing. - For ObjectEventHandlerNode-based processors, the runtime wraps your node in ConfigAwareEventProcessor, which also implements ConfigListener and forwards the config to your node.</p>"},{"location":"guide/injecting-config-into-a-processor/#2-make-your-component-receive-initial-config","title":"2) Make your component receive initial config","text":"<p>create a class that extends ObjectEventHandlerNode and implements ConfigListener.</p> <p>EventProcessorConfig can accept an ObjectEventHandlerNode directly. You can have your handler implement ConfigListener  to receive the config. At runtime this handler is wrapped in a DefaultEventProcessor (via ConfigAwareEventProcessor)  and participates like any other processor.</p> <pre><code>import com.fluxtion.runtime.node.ObjectEventHandlerNode;\nimport com.fluxtion.server.config.ConfigListener;\nimport com.fluxtion.server.config.ConfigMap;\nimport com.fluxtion.server.config.EventProcessorConfig;\n\nclass MyConfigAwareHandler extends ObjectEventHandlerNode implements ConfigListener {\n    private String greeting;\n    private int threshold;\n\n    @Override\n    public boolean initialConfig(ConfigMap config) {\n        this.greeting = config.getOrDefault(com.fluxtion.server.config.ConfigKey.of(\"greeting\", String.class), \"\");\n        this.threshold = config.getOrDefault(com.fluxtion.server.config.ConfigKey.of(\"threshold\", Integer.class), 0);\n        return true;\n    }\n\n    @Override\n    public boolean handleEvent(Object event) {\n        // your event handling using greeting/threshold\n        return true;\n    }\n}\n</code></pre>"},{"location":"guide/injecting-config-into-a-processor/#3-add-config-via-the-fluent-builder","title":"3) Add config via the fluent builder","text":"<p>Use EventProcessorConfig.Builder.putConfig(key, value) for each entry.</p> <pre><code>import com.fluxtion.server.config.AppConfig;\nimport com.fluxtion.server.config.EventProcessorConfig;\nimport com.fluxtion.server.config.EventProcessorGroupConfig;\n\nMyConfigAwareHandler handler = new MyConfigAwareHandler();\n\n// Register the handler using customHandler on the builder\nEventProcessorConfig&lt;?&gt; built = EventProcessorConfig.builder()\n        .customHandler(handler)\n        .putConfig(\"greeting\", \"hello\")\n        .putConfig(\"threshold\", 10)\n        .build();\n</code></pre> <p>At boot, the server will deliver this map to the handler if it exports ConfigListener.</p>"},{"location":"guide/injecting-config-into-a-processor/#4-end-to-end-example-runnable-test","title":"4) End-to-end example (runnable test)","text":"<p>Check this test that boots a server using the fluent API and verifies the initial config is delivered: InitialConfigFluentBootTest.java</p>"},{"location":"guide/injecting-config-into-a-processor/#5-tips","title":"5) Tips","text":"<ul> <li>Prefer ConfigKey for type-safe lookups from ConfigMap.</li> <li>Keep configuration keys stable and documented near your processor code.</li> <li>You can mix AppConfig-provided config with dynamic config updates later by defining your own config update events and handling them in the processor.</li> </ul>"},{"location":"guide/overview/","title":"Fluxtion Server: Concepts, Architecture, and Usage","text":"<p>This document provides a deeper overview of Fluxtion Server beyond the short README summary. It covers the event-driven architecture, core components, configuration, plugin model, lifecycle, and example usage.</p>"},{"location":"guide/overview/#event-processing-architecture","title":"Event Processing Architecture","text":"<pre><code>graph LR\nES[Event Sources] --&gt; FM[Flow Manager]\nFM --&gt; EH1[Event Handlers]\nFM --&gt; EH2[Event Handlers]\nFM --&gt; EH3[Event Handlers]\nEH1 --&gt; ESK[Event Sinks]\nEH2 --&gt; ESK[Event Sinks]\nEH3 --&gt; ESK[Event Sinks]\n\n    subgraph \"Agent thread group 1\"\n        EH1\n    end\n    subgraph \"Agent thread group 2\"\n        EH2\n    end\n    subgraph \"Agent thread group 3\"\n        EH3\n    end\n</code></pre>"},{"location":"guide/overview/#core-components","title":"Core Components","text":""},{"location":"guide/overview/#event-processing","title":"Event Processing","text":"<ul> <li>Event Sources: Producers that generate events</li> <li>Event Processors: Custom handlers for processing specific event types</li> <li>Event Sinks: Consumers that receive processed events</li> <li>Event Flow Manager: Coordinates event routing and processing</li> </ul>"},{"location":"guide/overview/#services","title":"Services","text":"<ul> <li>Dynamic service registration and management</li> <li>Support for both standard and agent-based services</li> <li>Runtime control (start/stop) of services</li> <li>Service dependency management</li> <li>Registered at the container level for lookup and use by event handlers</li> </ul>"},{"location":"guide/overview/#agent-hosted-application-logic","title":"Agent Hosted Application Logic","text":"<ul> <li>Background workers for continuous processing</li> <li>Configurable idle strategies</li> <li>Concurrent execution support</li> <li>Deadline-based scheduling</li> </ul>"},{"location":"guide/overview/#components-and-interaction-flow","title":"Components and Interaction Flow","text":"<ol> <li> <p>Event Sources (Feeds)</p> <ul> <li>Generate events into the system</li> <li>Can run as standard services or agents</li> <li>Examples: market data feeds, sensors, external integrations</li> </ul> </li> <li> <p>Event Handlers</p> <ul> <li>Organized into named groups, each with its own thread/idle strategy/log level</li> <li>Features: dynamic add/remove, configuration injection, audit logging</li> <li>Receive callbacks when feeds publish events; can use registered services; can publish to sinks</li> </ul> </li> <li> <p>Event Sinks</p> <ul> <li>Receive processed events and handle output distribution (DB, network, monitoring)</li> <li>Can operate as services or agents</li> </ul> </li> <li> <p>Flow Manager</p> <ul> <li>Central coordination component routing events and managing dispatch strategies</li> </ul> </li> </ol>"},{"location":"guide/overview/#configuration-yaml","title":"Configuration (YAML)","text":"<p>You can configure Fluxtion Server with YAML (or programmatically). Example snippet:</p> <pre><code># --------- EVENT INPUT FEEDS BEGIN CONFIG ---------\neventFeeds:\n  - instance: !!com.fluxtion.server.example.HeartBeatEventFeed { }\n    name: heartBeater\n    agentName: heartBeatPublisher-thread\n    broadcast: true\n# --------- EVENT INPUT FEEDS END CONFIG ---------\n\n# --------- EVENT HANDLERS BEGIN CONFIG ---------\neventHandlers:\n  - agentName: heartBeatProcessor-thread\n    eventHandlers:\n      heartBeatProcessor_1:\n        eventHandler: !!com.fluxtion.server.example.HeartBeatExampleProcessor { }\n        logLevel: DEBUG\n      heartBeatProcessor_2:\n        eventHandler: !!com.fluxtion.server.example.HeartBeatExampleProcessor { }\n        logLevel: DEBUG\n        # --------- EVENT HANDLERS END CONFIG ---------\n\n# --------- AGENT THREAD BEGIN CONFIG ---------\nagentThreads:\n  - agentName: heartBeatPublisher-thread\n    idleStrategy: !!com.fluxtion.agrona.concurrent.BusySpinIdleStrategy { }\n  - agentName: heartBeatProcessor-thread\n    idleStrategy: !!com.fluxtion.agrona.concurrent.BusySpinIdleStrategy { }\n# --------- AGENT THREAD END CONFIG ---------\n</code></pre>"},{"location":"guide/overview/#plugin-based-architecture","title":"Plugin-Based Architecture","text":"<p>Fluxtion Server implements a flexible plugin-based architecture across major components.</p>"},{"location":"guide/overview/#component-types","title":"Component Types","text":"<pre><code>graph TD \nA[Plugin System] --&gt; B[Event Feeds] \nA --&gt; C[Event Sinks] \nA --&gt; D[Services] \nA --&gt; E[Event Handlers]\n\nsubgraph \"Configuration\"\n    F[YAML Config]\n    G[Thread Config]\n    H[Idle Strategy]\nend\n\nF --&gt; A\n</code></pre> <ul> <li>Feeds: integrations/protocols/input formats/transforms</li> <li>Sinks: output formats/external integrations/transforms</li> <li>Services: business logic, integration, utilities</li> <li>Event Handlers: processing, transformation, business rules</li> </ul>"},{"location":"guide/overview/#idle-strategies","title":"Idle Strategies","text":"<ul> <li>Busy spin, yielding, sleeping, or custom</li> </ul>"},{"location":"guide/overview/#plugin-lifecycle","title":"Plugin Lifecycle","text":"<ol> <li>Registration: via configuration; dynamic loading; validation</li> <li>Initialization: configuration injection; resources; connections</li> <li>Execution: run in configured thread context; event processing; service provision</li> <li>Shutdown: cleanup; connection termination; persistence</li> </ol>"},{"location":"guide/overview/#best-practices","title":"Best Practices","text":"<ul> <li>Implement required interfaces and follow thread-safety guidelines</li> <li>Clear configuration and versioning; test configurations before deployment</li> <li>Choose appropriate idle strategies; monitor performance; optimize resources</li> <li>Robust error handling and meaningful logging</li> </ul>"},{"location":"guide/overview/#server-lifecycle","title":"Server Lifecycle","text":"<ol> <li>Boot: Server initialization with configuration</li> <li>Registration: Services and event processors</li> <li>Initialization: Component initialization</li> <li>Start: Activation of services and processors</li> <li>Runtime: Event processing and service execution</li> <li>Management: Dynamic control of components</li> </ol>"},{"location":"guide/overview/#see-also","title":"See Also","text":"<ul> <li>Architecture index</li> <li>Architecture overview</li> <li>Components</li> <li>Event flow</li> <li>Sequence diagrams</li> <li>Coding standards</li> </ul>"},{"location":"guide/subscribing-to-named-event-feeds/","title":"How to subscribe to specific named EventFeeds (and ignore others)","text":"<p>This guide shows how to subscribe to multiple EventFeeds by name using several named InMemoryEventSource inputs, and ignore any feeds whose names don\u2019t match. We will:</p> <ul> <li>Name each EventFeed via EventFeedConfig.name(\"...\")</li> <li>Subscribe to selected feed names from a processor using getContext().subscribeToNamedFeed(\"...\")</li> <li>Forward only events from the selected feeds to a sink</li> </ul> <p>Below we create three in-memory feeds: prices, orders, news. Our processor forwards only prices and news items to a sink, ignoring orders entirely.</p>"},{"location":"guide/subscribing-to-named-event-feeds/#sample-code","title":"Sample code","text":"<ul> <li>Test   source: src/test/java/com/fluxtion/server/example/NamedFeedsSubscriptionExampleTest.java</li> <li>Processor   node: src/test/java/com/fluxtion/server/example/NamedFeedsFilterHandler.java</li> </ul>"},{"location":"guide/subscribing-to-named-event-feeds/#processor-handler-that-subscribes-to-specific-feed-names","title":"Processor handler that subscribes to specific feed names","text":"<pre><code>package com.fluxtion.server.example;\n\nimport com.fluxtion.runtime.annotations.runtime.ServiceRegistered;\nimport com.fluxtion.runtime.node.ObjectEventHandlerNode;\nimport com.fluxtion.runtime.output.MessageSink;\n\nimport java.util.Set;\n\n/**\n * Example processor that only subscribes and forwards events from specific named EventFeeds.\n */\npublic class NamedFeedsFilterHandler extends ObjectEventHandlerNode {\n\n    private final Set&lt;String&gt; acceptedFeedNames;\n    private MessageSink&lt;String&gt; sink;\n\n    public NamedFeedsFilterHandler(Set&lt;String&gt; acceptedFeedNames) {\n        this.acceptedFeedNames = acceptedFeedNames;\n    }\n\n    @ServiceRegistered\n    public void wire(MessageSink&lt;String&gt; sink, String name) {\n        this.sink = sink;\n    }\n\n    @Override\n    public void start() {\n        acceptedFeedNames.forEach(feedName -&gt; getContext().subscribeToNamedFeed(feedName));\n    }\n\n    @Override\n    protected boolean handleEvent(Object event) {\n        if (sink == null || event == null) {\n            return true;\n        }\n        // In this example, the feed payload is a String, so just forward it\n        if (event instanceof String payload) {\n            sink.accept(payload);\n        }\n        return true;\n    }\n}\n</code></pre> <p>Notes:</p> <ul> <li>The example above subscribes at start() time to the selected feed names.</li> <li>The payload type is String in our example; adjust handling if your payload type differs.</li> </ul>"},{"location":"guide/subscribing-to-named-event-feeds/#wiring-several-named-inmemoryeventsource-feeds","title":"Wiring several named InMemoryEventSource feeds","text":"<ul> <li>Build an in-memory sink (MessageSink) that collects messages <li>Create three InMemoryEventSource instances <li>Register three EventFeedConfig entries with names: prices, orders, news</li> <li>Add the filter processor and the sink to AppConfig</li> <li>Boot the server and send events</li> <p>Snippet from the test setup:</p> <pre><code>import com.fluxtion.agrona.concurrent.BusySpinIdleStrategy;\nimport com.fluxtion.runtime.output.MessageSink;\nimport com.fluxtion.server.FluxtionServer;\nimport com.fluxtion.server.config.*;\nimport com.fluxtion.server.connector.memory.InMemoryEventSource;\nimport com.fluxtion.server.connector.memory.InMemoryMessageSink;\n\nimport java.util.List;\nimport java.util.Set;\n\n// In-memory sink\nInMemoryMessageSink memSink = new InMemoryMessageSink();\n\n// Feeds: three named in-memory sources\nInMemoryEventSource&lt;String&gt; prices = new InMemoryEventSource&lt;&gt;();\nprices.setCacheEventLog(true);\nInMemoryEventSource&lt;String&gt; orders = new InMemoryEventSource&lt;&gt;();\norders.setCacheEventLog(true);\nInMemoryEventSource&lt;String&gt; news = new InMemoryEventSource&lt;&gt;();\nnews.setCacheEventLog(true);\n\n// Processor that only forwards events from feeds: prices, news\nNamedFeedsFilterHandler filterHandler = new NamedFeedsFilterHandler(Set.of(\"prices\", \"news\"));\n\nEventProcessorGroupConfig processorGroup = EventProcessorGroupConfig.builder()\n        .agentName(\"processor-agent\")\n        .put(\"filter-processor\", new EventProcessorConfig(filterHandler))\n        .build();\n\n// Build EventFeed configs with names\nEventFeedConfig&lt;?&gt; pricesFeed = EventFeedConfig.builder()\n        .instance(prices)\n        .name(\"prices\")\n        .agent(\"prices-agent\", new BusySpinIdleStrategy())\n        .build();\n\nEventFeedConfig&lt;?&gt; ordersFeed = EventFeedConfig.builder()\n        .instance(orders)\n        .name(\"orders\")\n        .agent(\"orders-agent\", new BusySpinIdleStrategy())\n        .build();\n\nEventFeedConfig&lt;?&gt; newsFeed = EventFeedConfig.builder()\n        .instance(news)\n        .name(\"news\")\n        .agent(\"news-agent\", new BusySpinIdleStrategy())\n        .build();\n\nEventSinkConfig&lt;MessageSink&lt;?&gt;&gt; sinkCfg = EventSinkConfig.&lt;MessageSink&lt;?&gt;&gt;builder()\n        .instance(memSink)\n        .name(\"memSink\")\n        .build();\n\nAppConfig appConfig = AppConfig.builder()\n        .addProcessorGroup(processorGroup)\n        .addEventFeed(pricesFeed)\n        .addEventFeed(ordersFeed)\n        .addEventFeed(newsFeed)\n        .addEventSink(sinkCfg)\n        .build();\n\nFluxtionServer server = FluxtionServer.bootServer(appConfig, rec -&gt; {});\n</code></pre> <p>Publish some events and observe only selected feeds are forwarded:</p> <pre><code>prices.offer(\"p1\");\nprices.offer(\"p2\");\norders.offer(\"o1\");\norders.offer(\"o2\");\nnews.offer(\"n1\");\nnews.offer(\"n2\");\n\n// Expect only: p1, p2, n1, n2 in the sink\n</code></pre> <p>Only p1, p2 and n1, n2 will be forwarded by the processor; o1 and o2 are ignored because their feed name is not in the accepted set.</p>"},{"location":"guide/threading-model/","title":"Guide: Fluxtion Server Threading Model","text":"<p>This guide explains how Fluxtion Server uses threads to run your event processors, services, event sources, and the built\u2011in scheduler. It focuses on where your code executes, how agents communicate, and how to design components that are correct and performant under the single\u2011threaded processor model.</p> <p>You\u2019ll learn:</p> <ul> <li>Agent groups and their threads (processor groups, worker/service groups, scheduler)</li> <li>Single\u2011thread rule for processors and why it matters</li> <li>How event sources publish to processors (queues and wrapping)</li> <li>Lifecycle timing (init \u2192 start \u2192 startComplete \u2192 stop \u2192 tearDown)</li> <li>Where callbacks execute (processor thread vs service thread vs scheduler thread)</li> <li>How to safely hand work across threads (EventToQueuePublisher, ScheduledTriggerNode)</li> </ul> <p>References in this repository:</p> <ul> <li>Processor   agent: ComposingEventProcessorAgent</li> <li>Service agent: ComposingServiceAgent</li> <li>Scheduler   agent: DeadWheelScheduler</li> <li>Event source   base: AbstractEventSourceService (+   agent variant)</li> <li>Queue publisher: EventToQueuePublisher</li> </ul>"},{"location":"guide/threading-model/#1-big-picture","title":"1) Big picture","text":"<p>Fluxtion Server composes several \u201cagents,\u201d each typically running on its own thread:</p> <ul> <li>One or more Processor Agent Groups (each contains one or more StaticEventProcessor instances)</li> <li>One or more Service Agent Groups (each hosts zero or more worker services)</li> <li>One Scheduler Agent (the deadline wheel)</li> <li>Optional Agent\u2011hosted event sources (e.g., FileEventSource)</li> </ul> <p>Data is handed between agents through lock\u2011free single\u2011producer/single\u2011consumer queues managed by EventFlowManager and EventToQueuePublisher. Each processor runs single\u2011threaded on its agent thread \u2014 your processor code is not concurrently executed by multiple threads.</p>"},{"location":"guide/threading-model/#componentthread-overview","title":"Component/Thread overview","text":"<pre><code>flowchart LR\n    subgraph ServiceAgentGroup [Service Agent Group thread]\n        ES1[Agent-hosted Event Source]\n        WS1[Worker Service A]\n        WS2[Worker Service B]\n    end\n\n    subgraph ProcessorAgentGroup [Processor Agent Group thread]\n        P1[StaticEventProcessor #1]\n        P2[StaticEventProcessor #2]\n    end\n\n    subgraph SchedulerAgent [Scheduler Agent thread]\n        Svc[DeadWheelScheduler]\n    end\n\n    ES1 -- publish via EventToQueuePublisher --&gt; Q1[(Queue: fileFeed)] --&gt; P1\n    ES1 -- publish via EventToQueuePublisher --&gt; Q2[(Queue: fileFeed)] --&gt; P2\n    WS1 -- optional publish/events --&gt; Q3[(Queue: serviceFeed)] --&gt; P1\n    Svc -- expiry Runnable --&gt; WS1\n    Svc -- expiry Runnable --&gt; ES1\n\n    style ServiceAgentGroup fill:#eef,stroke:#88a\n    style ProcessorAgentGroup fill:#efe,stroke:#8a8\n    style SchedulerAgent fill:#fee,stroke:#a88\n</code></pre> <p>Notes:</p> <ul> <li>Each Agent Group is a thread that can host multiple components.</li> <li>Event publication crosses threads via queues. The publisher thread enqueues, the subscriber processor dequeues on its   own thread.</li> <li>Scheduler expiry actions run on the scheduler agent thread; to affect a processor, schedule a trigger that publishes   into the processor or use <code>ScheduledTriggerNode</code>.</li> </ul>"},{"location":"guide/threading-model/#2-lifecycle-and-when-things-start","title":"2) Lifecycle and when things start","text":"<p>All lifecycle participants (event sources, processors, services) follow this sequence:</p> <p>1) <code>init()</code> \u2014 light setup 2) <code>start()</code> \u2014 allocate resources; event sources may enable pre\u2011start caching 3) <code>startComplete()</code> \u2014 system is ready; sources replay caches and switch to publishing 4) <code>stop()</code> \u2014 stop work, flush/close resources 5) <code>tearDown()</code> \u2014 final cleanup</p> <p>Processor and service agents add their components and then call <code>startComplete()</code> once the group is active.</p>"},{"location":"guide/threading-model/#startup-sequence-high-level","title":"Startup sequence (high level)","text":"<pre><code>sequenceDiagram\n    participant CFG as ServerConfigurator\n    participant SVR as FluxtionServer\n    participant PGA as ComposingEventProcessorAgent (thread)\n    participant SGA as ComposingServiceAgent (thread)\n    participant SCH as DeadWheelScheduler (thread)\n\n    CFG-&gt;&gt;SVR: register services / feeds / processors\n    SVR-&gt;&gt;SGA: register worker services\n    SGA-&gt;&gt;SGA: init() services\n    SGA-&gt;&gt;SGA: inject scheduler + services\n    SGA-&gt;&gt;SGA: start() services\n    SGA-&gt;&gt;SGA: add Agent delegates\n\n    SVR-&gt;&gt;PGA: add processors\n    PGA-&gt;&gt;PGA: inject scheduler + services\n    PGA-&gt;&gt;PGA: start() processors\n    PGA-&gt;&gt;PGA: startComplete() processors\n\n    Note over SGA: When group ACTIVE\n    SGA-&gt;&gt;SGA: startComplete() services\n\n    Note over SCH: Scheduler agent thread running doWork()\n</code></pre>"},{"location":"guide/threading-model/#3-event-dispatch-path","title":"3) Event dispatch path","text":"<p>Agent\u2011hosted event sources (e.g., <code>FileEventSource</code>) typically publish on their own thread. The data is mapped/wrapped by <code>EventToQueuePublisher</code> and offered to one or more target queues. Processors consume from those queues on their own agent thread.</p> <pre><code>sequenceDiagram\n    participant SRC as FileEventSource (service agent thread)\n    participant PUB as EventToQueuePublisher\n    participant Q as OneToOneConcurrentArrayQueue\n    participant P as StaticEventProcessor (processor thread)\n\n    SRC-&gt;&gt;PUB: publish(line)\n    PUB-&gt;&gt;PUB: map + wrap (strategy)\n    PUB-&gt;&gt;Q: offer(item)\n    Note right of Q: Cross-thread boundary\n    P-&gt;&gt;Q: poll\n    Q--&gt;&gt;P: item\n    P-&gt;&gt;P: invoke handler(s)\n</code></pre> <p>Key details:</p> <ul> <li><code>EventWrapStrategy</code> controls whether items are wrapped in <code>NamedFeedEvent</code> or sent raw.</li> <li>If <code>cacheEventLog</code> is enabled in the publisher, events are recorded and replayed on <code>startComplete()</code>.</li> <li><code>EventToQueuePublisher</code> bounds spin when queues are contended to avoid blocking publishers; slow consumers are warned.</li> </ul>"},{"location":"guide/threading-model/#4-where-does-my-code-run","title":"4) Where does my code run?","text":"<ul> <li>Processor event handlers (e.g., <code>ObjectEventHandlerNode#handleEvent</code>) run on the Processor Agent Group thread.</li> <li>Agent\u2011hosted services and agent\u2011hosted event sources run their <code>doWork()</code> on the Service Agent Group thread that hosts   them.</li> <li>Scheduler expiry actions run on the Scheduler Agent thread.</li> <li>Admin commands registered within a processor context are delivered into that processor\u2019s queue and executed on its   thread; otherwise they execute on the caller thread.</li> </ul> <p>Implications:</p> <ul> <li>Inside a processor, your state is single\u2011threaded \u2014 no external synchronization is required for state mutated only by   that processor.</li> <li>To update a processor from another thread (service, scheduler), publish an event into the processor\u2019s queue. Don\u2019t   directly mutate processor state from other threads.</li> </ul>"},{"location":"guide/threading-model/#5-moving-work-between-threads-safely","title":"5) Moving work between threads safely","text":"<p>Common patterns to marshal work back into a processor context:</p> <ul> <li>Event publication from services/sources using <code>EventToQueuePublisher</code> (via an <code>EventSource</code> or an admin command routed   to a processor queue).</li> <li>Use <code>ScheduledTriggerNode</code> to schedule a new event cycle into the processor after a delay; the trigger causes   <code>fireNewEventCycle()</code> to run on the processor thread.</li> </ul> <p>Example using <code>ScheduledTriggerNode</code>:</p> <pre><code>public class MySchedulerAwareHandler extends com.fluxtion.runtime.node.ObjectEventHandlerNode {\n    private final com.fluxtion.server.service.scheduler.ScheduledTriggerNode trigger =\n            new com.fluxtion.server.service.scheduler.ScheduledTriggerNode();\n\n    // After wiring, call this from handleEvent or during start\n    void scheduleTick(long millis) {\n        trigger.triggerAfterDelay(millis); // later causes a new event cycle on this processor thread\n    }\n}\n</code></pre>"},{"location":"guide/threading-model/#6-best-practices","title":"6) Best practices","text":"<ul> <li>Keep <code>Agent#doWork()</code> non\u2011blocking; do small chunks and return 0 when idle.</li> <li>Don\u2019t call blocking IO from processor event handlers; offload to a worker service and publish results back.</li> <li>For periodic tasks, prefer the scheduler (rescheduling pattern) over sleeping in <code>doWork()</code>.</li> <li>Guard verbose logging in hot paths with <code>log.isLoggable(...)</code> or cached flags.</li> <li>If you need pre\u2011start replay, enable publisher caching in your source\u2019s <code>start()</code> and call <code>dispatchCachedEventLog()</code>   on <code>startComplete()</code>.</li> <li>Use meaningful agent group names and idle strategies in <code>AppConfig</code> for observability and performance tuning.</li> </ul>"},{"location":"guide/threading-model/#7-glossary-of-threads","title":"7) Glossary of threads","text":"<ul> <li>Processor Agent Group thread: runs one or more <code>StaticEventProcessor</code> instances (single\u2011threaded event handling).</li> <li>Service Agent Group thread: runs worker services and agent\u2011hosted event sources (<code>Agent#doWork</code>).</li> <li>Scheduler Agent thread: runs <code>DeadWheelScheduler</code> and executes expiry <code>Runnable</code>s.</li> </ul>"},{"location":"guide/threading-model/#8-related-docs","title":"8) Related docs","text":"<ul> <li>Using the scheduler service: using-the-scheduler-service</li> <li>Writing an event source plugin: writing-an-event-source-plugin</li> <li>Writing a service plugin: writing-a-service-plugin</li> <li>Writing an admin command: writing-an-admin-command</li> <li>How to core\u2011pin agent threads: how-to-core-pin</li> <li>Architecture + sequence diagrams: architecture</li> </ul>"},{"location":"guide/threading-model/#9-optional-core-pinning-for-agent-threads","title":"9) Optional: Core pinning for agent threads","text":"<p>Fluxtion Server supports best-effort CPU core pinning for agent threads. This can help reduce context switches and improve tail latency on systems where CPU affinity is desirable.</p> <p>Key points: - Configure per-agent core pinning using AppConfig\u2019s agent Threads: ThreadConfig has an optional coreId field (zero-based CPU index). - Pinning is applied inside the agent thread itself during start (onStart) for both processor and service agent groups:   - Processor agent: ComposingEventProcessorAgent   - Service agent: ComposingServiceAgent - Fluxtion uses a lightweight helper CoreAffinity that attempts to pin via reflection to OpenHFT\u2019s Affinity library if present; otherwise it logs and no-ops.</p> <p>Configure via fluent builder: <pre><code>import com.fluxtion.server.config.AppConfig;\nimport com.fluxtion.server.config.ThreadConfig;\nimport com.fluxtion.agrona.concurrent.BusySpinIdleStrategy;\n\nAppConfig appConfig = AppConfig.builder()\n    // Configure processor agent group thread\n    .addThread(ThreadConfig.builder()\n        .agentName(\"processor-agent\")\n        .idleStrategy(new BusySpinIdleStrategy())\n        .coreId(0) // pin to CPU core 0 (zero-based index)\n        .build())\n    // Configure service agent group thread\n    .addThread(ThreadConfig.builder()\n        .agentName(\"service-agent\")\n        .coreId(2) // pin to CPU core 2\n        .build())\n    // ... add groups/feeds/services as usual\n    .build();\n</code></pre></p> <p>Runtime behavior: - When an agent group thread starts, the server resolves the configured core for that agent via FluxtionServer.resolveCoreIdForAgentName and calls CoreAffinity.pinCurrentThreadToCore(coreId). If no coreId is configured, nothing is done. - If OpenHFT\u2019s Affinity is not on the classpath, pinning is skipped with an info log.</p> <p>Optional dependency for pinning: - To enable actual OS-level pinning, add the test/runtime dependency on OpenHFT Affinity in your project.   See this repository\u2019s POM for an example test-scoped optional dependency: pom.xml (artifact net.openhft:affinity). - A simple optional test that exercises pinning via reflection is provided here: CoreAffinityOptionalTest.</p> <p>Notes: - Core IDs are zero-based and depend on your OS/CPU topology. - Pinning can improve determinism but may reduce OS scheduling flexibility; benchmark your workload.</p>"},{"location":"guide/using-the-scheduler-service/","title":"Guide: Using the Scheduler Service in Fluxtion Server","text":"<p>This guide explains how to use the built\u2011in scheduler to run actions in the future or after a delay. The scheduler is exposed to processors and services as <code>SchedulerService</code> and implemented by <code>DeadWheelScheduler</code> under the hood.</p> <p>You\u2019ll learn:</p> <ul> <li>What the SchedulerService is and when to use it</li> <li>How the scheduler is wired into processors and services</li> <li>API overview: scheduleAtTime, scheduleAfterDelay, time helpers</li> <li>Patterns: one\u2011shot timers, periodic jobs (by rescheduling), triggering event cycles</li> <li>Threading and safety considerations</li> <li>References to examples and source code</li> </ul>"},{"location":"guide/using-the-scheduler-service/#what-is-the-schedulerservice","title":"What is the SchedulerService?","text":"<p><code>SchedulerService</code> provides simple, low\u2011overhead scheduling primitives backed by an Agrona deadline timer wheel. It offers:</p> <ul> <li>scheduleAtTime(epochMillis, action)</li> <li>scheduleAfterDelay(delayMillis, action)</li> <li>milliTime()/microTime()/nanoTime() helpers</li> </ul> <p>Interface:</p> <pre><code>public interface SchedulerService {\n    long scheduleAtTime(long expireTimeMillis, Runnable expiryAction);\n    long scheduleAfterDelay(long waitTimeMillis, Runnable expiryAction);\n    long milliTime();\n    long microTime();\n    long nanoTime();\n}\n</code></pre> <p>The default implementation is <code>com.fluxtion.server.service.scheduler.DeadWheelScheduler</code>, which also implements <code>com.fluxtion.agrona.concurrent.Agent</code> and polls timers on an agent thread.</p>"},{"location":"guide/using-the-scheduler-service/#how-the-scheduler-is-wired-in","title":"How the scheduler is wired in","text":"<p>You do not need to manually register a scheduler. Fluxtion Server provides one and injects it into:</p> <ul> <li>Each StaticEventProcessor hosted in an agent group</li> <li>Each worker service (agent\u2011hosted service)</li> </ul> <p>Injection happens via <code>@ServiceRegistered</code> methods. Two examples in this repository:</p> <ul> <li>Event sources using <code>AbstractEventSourceService</code> receive the scheduler through:   <pre><code>@ServiceRegistered\npublic void scheduler(SchedulerService scheduler) { this.scheduler = scheduler; }\n</code></pre></li> <li>Any processor or service can declare a similar injection point.</li> </ul> <p>Under the covers, the composing agents (<code>ComposingEventProcessorAgent</code> and <code>ComposingServiceAgent</code>) create a <code>DeadWheelScheduler</code> and register it as a <code>Service&lt;SchedulerService&gt;</code> that is injected into components in that group.</p>"},{"location":"guide/using-the-scheduler-service/#basic-usage","title":"Basic usage","text":""},{"location":"guide/using-the-scheduler-service/#oneshot-delay","title":"One\u2011shot delay","text":"<pre><code>@ServiceRegistered\npublic void scheduler(SchedulerService scheduler) {\n    this.scheduler = scheduler;\n}\n\npublic void doSomethingLater() {\n    scheduler.scheduleAfterDelay(250, () -&gt; {\n        // code to run ~250ms later\n        publish(\"tick\");\n    });\n}\n</code></pre>"},{"location":"guide/using-the-scheduler-service/#schedule-at-a-wallclock-time-epoch-millis","title":"Schedule at a wall\u2011clock time (epoch millis)","text":"<pre><code>long runAt = System.currentTimeMillis() + 1_000; // ~1s from now\nscheduler.scheduleAtTime(runAt, this::rollover);\n</code></pre>"},{"location":"guide/using-the-scheduler-service/#periodic-job-rescheduling-pattern","title":"Periodic job (rescheduling pattern)","text":"<p>The API is one\u2011shot; to run periodically, reschedule from inside the task.</p> <pre><code>private void scheduleHeartbeat(long periodMs) {\n    scheduler.scheduleAfterDelay(periodMs, () -&gt; {\n        emitHeartbeat();\n        scheduleHeartbeat(periodMs); // reschedule\n    });\n}\n</code></pre> <p>A similar pattern is used in the example <code>HeartBeatEventFeed</code> (see src/test/java/com/fluxtion/server/example/HeartBeatEventFeed.java), which publishes a heartbeat at a configurable interval (that example also shows an Agent\u2011based doWork loop alternative).</p>"},{"location":"guide/using-the-scheduler-service/#trigger-an-event-cycle-after-a-delay","title":"Trigger an event cycle after a delay","text":"<p>Use <code>ScheduledTriggerNode</code> when you want to schedule a new event cycle (callback) into the event processor:</p> <pre><code>public class MyTrigger extends com.fluxtion.server.service.scheduler.ScheduledTriggerNode {\n    public void startLater() {\n        triggerAfterDelay(100); // fires a new event cycle in ~100ms\n    }\n}\n</code></pre> <p><code>ScheduledTriggerNode</code> injects the scheduler via <code>@ServiceRegistered</code> and calls <code>fireNewEventCycle()</code> when the delay expires.</p>"},{"location":"guide/using-the-scheduler-service/#threading-model-and-safety","title":"Threading model and safety","text":"<ul> <li>DeadWheelScheduler runs on an agent thread (it is an Agrona <code>Agent</code>). Expiry actions (<code>Runnable</code>) execute on the   scheduler\u2019s agent thread, not on your processor\u2019s event thread.</li> <li>If your action needs to interact with a processor\u2019s single\u2011threaded state, prefer to publish an event or use a   callback node to marshal back into the processor\u2019s context.</li> <li>Keep expiry actions non\u2011blocking and lightweight.</li> <li>Time helpers (<code>milliTime/microTime/nanoTime</code>) return times based on the scheduler\u2019s clock.</li> </ul>"},{"location":"guide/using-the-scheduler-service/#cancellation-and-ids","title":"Cancellation and IDs","text":"<p>Both scheduling methods return a long ID, but the current API does not expose a cancellation call. Treat timers as one\u2011shot. For periodic work, use the rescheduling pattern shown above. If you need explicit cancellation, guard your actions with a volatile flag you check at the start of the runnable.</p> <p>Example:</p> <pre><code>private volatile boolean running = true;\n\npublic void startPeriodic() {\n    scheduleHeartbeat(500);\n}\n\npublic void stopPeriodic() {\n    running = false;\n}\n\nprivate void scheduleHeartbeat(long periodMs) {\n    scheduler.scheduleAfterDelay(periodMs, () -&gt; {\n        if (!running) return; // simple cancel guard\n        emitHeartbeat();\n        scheduleHeartbeat(periodMs);\n    });\n}\n</code></pre>"},{"location":"guide/using-the-scheduler-service/#endtoend-examples-in-this-repository","title":"End\u2011to\u2011end examples in this repository","text":"<ul> <li>Heartbeat publisher (uses agent loop, shows timing/rate):   <code>src/test/java/com/fluxtion/server/example/HeartBeatEventFeed.java</code></li> <li>Simple scheduled trigger node: <code>src/main/java/com/fluxtion/server/service/scheduler/ScheduledTriggerNode.java</code></li> <li>Injection sites:<ul> <li><code>AbstractEventSourceService.scheduler(SchedulerService)</code></li> <li><code>ComposingEventProcessorAgent</code> and <code>ComposingServiceAgent</code> where the scheduler is created and injected</li> </ul> </li> </ul>"},{"location":"guide/using-the-scheduler-service/#tips-and-pitfalls","title":"Tips and pitfalls","text":"<ul> <li>Prefer rescheduling over loops/sleeps\u2014expiry actions should be quick.</li> <li>Don\u2019t perform blocking IO in expiry actions; dispatch work to appropriate components or queues.</li> <li>For processor state mutations, marshal via events/callback nodes to stay within the processor\u2019s single thread.</li> <li>Use <code>milliTime()</code> instead of <code>System.currentTimeMillis()</code> when aligning to the scheduler\u2019s notion of time.</li> </ul>"},{"location":"guide/using-the-scheduler-service/#references","title":"References","text":"<ul> <li>Interface: SchedulerService.java</li> <li>Default   implementation: DeadWheelScheduler.java</li> <li>Trigger   helper: ScheduledTriggerNode.java</li> <li>Wiring an event   processor: ComposingEventProcessorAgent.java</li> <li>Wiring a   services: ComposingServiceAgent.java</li> </ul>"},{"location":"guide/writing-a-custom-event-to-invoke-strategy/","title":"How to write a custom EventToInvokeStrategy","text":"<p>This guide shows how to build and plug in your own EventToInvokeStrategy to control how events are dispatched from queues to StaticEventProcessor instances.</p> <p>When to customize: - Filter which processors can receive events - Transform events before delivery - Route or multiplex events differently than the default onEvent dispatch - Callback to a strongly-typed interface</p>"},{"location":"guide/writing-a-custom-event-to-invoke-strategy/#1-choose-a-base-implement-the-interface-or-extend-the-helper","title":"1) Choose a base: implement the interface or extend the helper","text":"<p>You can: - Implement the low-level interface directly: EventToInvokeStrategy - Or extend the convenience base class: AbstractEventToInvocationStrategy</p> <p>The helper already manages: - Registration/deregistration of processors (thread-safe list) - Per-dispatch ProcessorContext current-processor handling - Synthetic clock wiring when you call processEvent(event, time)</p> <p>With the helper, you only implement: - protected void dispatchEvent(Object event, StaticEventProcessor eventProcessor) - protected boolean isValidTarget(StaticEventProcessor eventProcessor)</p>"},{"location":"guide/writing-a-custom-event-to-invoke-strategy/#2-example-filter-targets-and-transform-events-strongly-typed-callback","title":"2) Example: filter targets and transform events (strongly-typed callback)","text":"<p>The following example accepts only processors that implement a MarkerProcessor interface and uppercases String events  before delivering them via a strongly-typed callback or onEvent(Object) if the event is not a String:</p> <pre><code>import com.fluxtion.runtime.StaticEventProcessor;\nimport com.fluxtion.server.dispatch.AbstractEventToInvocationStrategy;\n\npublic interface MarkerProcessor {\n    void onString(String s);\n}\n\npublic class UppercaseStringStrategy extends AbstractEventToInvocationStrategy {\n    @Override\n    protected void dispatchEvent(Object event, StaticEventProcessor eventProcessor) {\n        if (event instanceof String s &amp;&amp; eventProcessor instanceof MarkerProcessor marker) {\n            marker.onString(s.toUpperCase());\n        } else {\n            //normal dispatch to onEvent\n            eventProcessor.onEvent(event);\n        }\n    }\n\n    @Override\n    protected boolean isValidTarget(StaticEventProcessor eventProcessor) {\n        return eventProcessor instanceof MarkerProcessor;\n    }\n}\n</code></pre> <p>Notes: - Using an invoker strategy allows your event processors to be strongly typed (e.g., MarkerProcessor.onString), while the strategy takes responsibility for mapping inbound events to the correct callback. This reduces boilerplate and centralizes dispatch logic, which can make future maintenance easier. - ProcessorContext is automatically set to the current target processor during dispatch. Inside the processor, you can call ProcessorContext.currentProcessor() if needed. - If you call processEvent(event, time), AbstractEventToInvocationStrategy wires a synthetic clock into each target processor via setClockStrategy so that processors can use a provided time source.</p>"},{"location":"guide/writing-a-custom-event-to-invoke-strategy/#3-wire-your-strategy-into-the-runtime","title":"3) Wire your strategy into the runtime","text":"<p>Register your strategy as a factory for a CallBackType. </p> <p>Via AppConfig fluent builder (server will register on boot), and override the default onEvent strategy, ON_EVENT_CALL_BACK, delivers raw events to processors via the onEvent(Object) callback. <pre><code>// Register for the standard onEvent path (optional if you want raw onEvent only)\nAppConfig appConfig = AppConfig.builder()\n    .onEventInvokeStrategy(UppercaseStringStrategy::new)\n    // add groups, feeds, sinks, services\n    .build();\nFluxtionServer server = FluxtionServer.bootServer(appConfig);\n</code></pre> For a full end-to-end example that boots the server via the fluent AppConfig builder and verifies the custom strategy,  see the test method fluentBuilder_bootsServer_and_applies_custom_strategy in CustomEventToInvokeStrategyTest.java.</p> <p>Via FluxtionServer (register at runtime), beware that custom strategy will not affect queues that are already in use  and have been registered before the new invoker strategy is registered. <pre><code>FluxtionServer server = FluxtionServer.bootServer(appConfig);\nserver.registerEventMapperFactory(UppercaseStringStrategy::new, CallBackType.ON_EVENT_CALL_BACK);\n</code></pre></p>"},{"location":"guide/writing-a-custom-event-to-invoke-strategy/#4-testing-tips","title":"4) Testing tips","text":"<ul> <li>Use a RecordingProcessor that implements StaticEventProcessor (and your marker if filtering) to capture received events.</li> <li>Assert listenerCount() after registering processors to ensure your isValidTarget filter works.</li> <li>Publish test events through EventToQueuePublisher and call agent.doWork() to force processing.</li> <li>If you need timestamp semantics, publish a ReplayRecord through the EventToQueuePublisher or use processEvent(event, time) inside a controlled driver and have your processor consult its clock strategy.</li> </ul> <p>See CustomEventToInvokeStrategyTest.java for a complete, runnable example. It includes: - A direct EventFlowManager usage example of a custom strategy \u2713 - A fluent AppConfig builder example that boots a FluxtionServer and registers the custom strategy \u2713</p> <p>References: - EventFlowManager - EventToQueuePublisher - EventSourceKey - FluxtionServer - CallBackType - AbstractEventToInvocationStrategy - ProcessorContext</p>"},{"location":"guide/writing-a-message-sink-plugin/","title":"Guide: Writing a Message Sink Plugin for Fluxtion Server","text":"<p>This guide explains how to implement and integrate a custom message sink (an output connector) for Fluxtion Server. A message sink consumes values produced by event processors and forwards them to an external system (e.g., file, database, HTTP, Kafka, etc.).</p> <p>You\u2019ll learn:</p> <ul> <li>When and how to create a sink plugin</li> <li>Extending <code>AbstractMessageSink</code> and implementing <code>sendToSink</code></li> <li>Managing lifecycle (init/start/stop/tearDown)</li> <li>Using value mapping (<code>valueMapper</code>) to transform payloads</li> <li>Registering your sink via <code>EventSinkConfig</code> or <code>ServiceConfig</code></li> <li>Optional: Hosting a sink on its own agent thread</li> <li>Testing patterns and common pitfalls</li> </ul>"},{"location":"guide/writing-a-message-sink-plugin/#when-to-write-a-sink","title":"When to write a sink","text":"<p>Create a custom sink when your application needs to publish events to an external target that is not provided out-of-the-box. Examples: writing to a DB, pushing to a REST endpoint, publishing to a message broker, or serializing to a bespoke format.</p> <p>If your sink is IO-bound and simple (e.g., append a line to a file), you can keep it synchronous in <code>sendToSink</code>. For heavier workloads or where you need back-pressure buffering, consider an agent-hosted service that pulls from a queue and writes asynchronously (see Agent-hosted sinks).</p>"},{"location":"guide/writing-a-message-sink-plugin/#base-class-abstractmessagesink","title":"Base class: AbstractMessageSink","text":"<p>All sinks should extend <code>com.fluxtion.runtime.output.AbstractMessageSink&lt;T&gt;</code>. This base class:</p> <ul> <li>Exposes <code>accept(Object value)</code> to upstream processors.</li> <li>Applies an optional <code>valueMapper</code> before calling your sink.</li> <li>Delegates final output to your implementation via <code>protected void sendToSink(T value)</code>.</li> </ul> <p>The generic type parameter <code>T</code> denotes the post-mapping type your sink expects (often <code>Object</code> for general-purpose sinks). For example sinks in this repo use <code>Object</code>:</p> <ul> <li>File sink: <code>FileMessageSink extends AbstractMessageSink&lt;Object&gt;</code></li> <li>In-memory sink (for testing): <code>InMemoryMessageSink extends AbstractMessageSink&lt;Object&gt;</code></li> </ul>"},{"location":"guide/writing-a-message-sink-plugin/#minimal-implementation","title":"Minimal implementation","text":"<p>Below is a skeleton you can copy. Replace the TODOs with your target integration:</p> <pre><code>package com.mycompany.connector;\n\nimport com.fluxtion.runtime.lifecycle.Lifecycle;\nimport com.fluxtion.runtime.output.AbstractMessageSink;\nimport lombok.Getter;\nimport lombok.Setter;\nimport lombok.extern.java.Log;\n\n@Log\npublic class MyCustomMessageSink extends AbstractMessageSink&lt;Object&gt; implements Lifecycle {\n\n    @Getter @Setter\n    private String endpoint; // e.g., file name, URL, topic, etc.\n\n    // Acquire resources (connections, clients) here\n    @Override\n    public void init() {\n        // no-op or lightweight setup\n    }\n\n    @Override\n    public void start() {\n        // open connections/resources; e.g., create HTTP client, open file handle\n        // throw a RuntimeException if the sink can't start\n    }\n\n    @Override\n    protected void sendToSink(Object value) {\n        // called by AbstractMessageSink.accept() after valueMapper is applied\n        // perform the final write/publish\n        // Examples:\n        // - printStream.println(value)\n        // - httpClient.post(endpoint, value)\n        // - producer.send(topic, serialize(value))\n    }\n\n    @Override\n    public void stop() {\n        // flush &amp; close resources (idempotent)\n    }\n\n    @Override\n    public void tearDown() {\n        stop();\n    }\n}\n</code></pre> <p>Key points:</p> <ul> <li>Implement <code>sendToSink(value)</code> with the minimum synchronous work needed to persist or publish the value.</li> <li>If your target may block for a long time, consider a non-blocking approach (queue + background agent) instead of doing   heavy work in <code>sendToSink</code>.</li> </ul>"},{"location":"guide/writing-a-message-sink-plugin/#value-mapping-valuemapper","title":"Value mapping (valueMapper)","text":"<p>Upstream processors call <code>accept(event)</code> with arbitrary objects. If your sink expects a specific representation (e.g., JSON string), configure a mapper to transform inputs before <code>sendToSink</code> is called.</p> <ul> <li>Programmatic configuration via <code>EventSinkConfig</code>:</li> </ul> <pre><code>import com.fluxtion.server.config.EventSinkConfig;\n\nEventSinkConfig&lt;MyCustomMessageSink&gt; sinkCfg = EventSinkConfig.&lt;MyCustomMessageSink&gt;builder()\n        .instance(mySink)\n        .name(\"mySink\")\n        .valueMapper((Object in) -&gt; toJson(in)) // map to JSON string\n        .build();\n</code></pre> <ul> <li>Or set mapper directly on the sink instance:</li> </ul> <pre><code>mySink.setValueMapper((Object in) -&gt; toJson(in));\n</code></pre> <p>The server will call <code>accept(value)</code>, which applies the mapper and then calls <code>sendToSink(mappedValue)</code>.</p>"},{"location":"guide/writing-a-message-sink-plugin/#registering-your-sink-with-the-server","title":"Registering your sink with the server","text":"<p>There are two common ways to register sinks:</p> <p>1) Preferred: <code>EventSinkConfig</code> (works with any <code>MessageSink&lt;?&gt;</code>)</p> <pre><code>import com.fluxtion.server.config.AppConfig;\nimport com.fluxtion.server.config.EventSinkConfig;\n\nMyCustomMessageSink mySink = new MyCustomMessageSink();\nmySink.setEndpoint(\"/tmp/out.log\");\n\nEventSinkConfig&lt;MyCustomMessageSink&gt; sinkCfg = EventSinkConfig.&lt;MyCustomMessageSink&gt;builder()\n        .instance(mySink)\n        .name(\"mySink\")\n        .build();\n\nAppConfig app = AppConfig.builder()\n        .addEventSink(sinkCfg)\n        .build();\n</code></pre> <p>2) Alternative: Register as a generic service (works for any type)</p> <pre><code>import com.fluxtion.server.config.ServiceConfig;\n\nServiceConfig&lt;MyCustomMessageSink&gt; svc = ServiceConfig.&lt;MyCustomMessageSink&gt;builder()\n        .service(mySink)\n        .serviceClass(MyCustomMessageSink.class)\n        .name(\"mySink\")\n        .build();\n\nAppConfig app = AppConfig.builder()\n        .addService(svc)\n        .build();\n</code></pre> <p>When using the fluent builder, the server injects registered services into processors that declare them (via <code>@ServiceRegistered</code>). For example:</p> <pre><code>public class MyHandler extends com.fluxtion.runtime.node.ObjectEventHandlerNode {\n    private com.fluxtion.runtime.output.MessageSink sink;\n\n    @com.fluxtion.runtime.annotations.runtime.ServiceRegistered\n    public void wire(com.fluxtion.runtime.output.MessageSink sink, String name) {\n        this.sink = sink;\n    }\n\n    @Override\n    protected boolean handleEvent(Object event) {\n        if (sink != null) sink.accept(event);\n        return true;\n    }\n}\n</code></pre> <p>See also: the example guide wiring <code>FileMessageSink</code> and <code>InMemoryEventSource</code> in <code>docs/guide/file-and-memory-feeds-example.md</code>.</p>"},{"location":"guide/writing-a-message-sink-plugin/#agent-hosted-sinks-optional","title":"Agent-hosted sinks (optional)","text":"<p>If your sink needs its own thread (e.g., to buffer and flush asynchronously), you can host it on an agent thread by making the sink also implement Agrona <code>Agent</code> or wrapping with a worker service pattern. In most cases, output sinks can remain simple <code>Lifecycle</code> components without an agent.</p> <p>To run a sink on its own agent thread via <code>EventSinkConfig</code>:</p> <pre><code>EventSinkConfig&lt;MyCustomMessageSink&gt; sinkCfg = EventSinkConfig.&lt;MyCustomMessageSink&gt;builder()\n        .instance(mySink)\n        .name(\"mySink\")\n        .agent(\"sink-agent-thread\", new com.fluxtion.agrona.concurrent.BusySpinIdleStrategy())\n        .build();\n\nAppConfig app = AppConfig.builder()\n        .addEventSink(sinkCfg)\n        .build();\n</code></pre> <p>Note: For this to work, the <code>instance</code> must also implement <code>com.fluxtion.agrona.concurrent.Agent</code> (or be wrapped in a custom ServiceAgent). If your sink does not implement <code>Agent</code>, omit the <code>agent(...)</code> configuration.</p>"},{"location":"guide/writing-a-message-sink-plugin/#testing-your-sink","title":"Testing your sink","text":"<ul> <li>For sinks writing to files: open the file on <code>start()</code>, write in <code>sendToSink</code>, flush/close on <code>stop()</code>.</li> <li>For in-memory sinks: collect values into a thread-safe list; expose a snapshot getter. See   <code>com.fluxtion.server.connector.memory.InMemoryMessageSink</code>.</li> <li>Unit test pattern used in this repo:<ul> <li>Create a testable subclass that exposes a public method calling <code>sendToSink</code> (since it\u2019s protected) or test via   <code>accept</code> with a mapper if needed.</li> <li>Drive lifecycle methods (<code>init()</code>, <code>start()</code>, <code>stop()</code>).</li> </ul> </li> </ul> <p>Example from this repository (<code>FileMessageSinkTest</code> style):</p> <pre><code>static class TestableMySink extends MyCustomMessageSink {\n    public void write(Object value) { super.sendToSink(value); }\n}\n</code></pre>"},{"location":"guide/writing-a-message-sink-plugin/#common-pitfalls-and-tips","title":"Common pitfalls and tips","text":"<ul> <li>Don\u2019t perform heavy blocking operations inside <code>sendToSink</code> if your processors are latency sensitive; consider an   internal queue + background agent.</li> <li>Use <code>valueMapper</code> to isolate serialization/formatting from transport code.</li> <li>Make <code>stop()</code> idempotent and always close or release resources.</li> <li>If using files, create parent directories and use UTF-8 consistently.</li> <li>Log at <code>FINE</code> or <code>FINER</code> levels inside hot paths to avoid overhead; prefer guarded logs.</li> </ul>"},{"location":"guide/writing-a-message-sink-plugin/#reference-implementations-in-this-repo","title":"Reference implementations in this repo","text":"<ul> <li>File sink: FileMessageSink.java \u2014   appends   each published message as a line to a file.</li> <li>In-memory sink (for   testing): InMemoryMessageSink.java \u2014   accumulates messages in memory.</li> <li>End-to-end usage: file-and-memory-feeds-example.md \u2014 shows processor wiring and   registering sinks with <code>EventSinkConfig</code>.</li> </ul> <p>With this structure, you can implement custom sinks for any target in a few lines, register them with <code>AppConfig</code>, and begin publishing from your processors immediately.</p>"},{"location":"guide/writing-a-publishing-service-plugin/","title":"How to write a publishing Service plugin (processor subscribes via @ServiceRegistered)","text":"<p>This guide shows how to implement a Service plugin that can publish events into the Fluxtion event flow, and how an EventProcessor subscribes to that service. The processor receives the service instance via <code>@ServiceRegistered</code> and calls <code>service.subscribe()</code> to start receiving events.</p> <p>We will: - Implement a minimal <code>PublishingService</code> by extending <code>AbstractEventSourceService&lt;String&gt;</code> - Implement a processor that injects the service via <code>@ServiceRegistered</code>, calls <code>subscribe()</code> in <code>start()</code>, and forwards events to a sink - Wire everything with <code>AppConfig</code>, publish a few events via the service, and verify reception in a sink</p> <p>References in this repository: - Example service: src/test/java/com/fluxtion/server/example/PublishingService.java - Example processor: src/test/java/com/fluxtion/server/example/PublishingServiceSubscriberHandler.java - Example test: src/test/java/com/fluxtion/server/example/PublishingServicePluginExampleTest.java - Service base class: src/main/java/com/fluxtion/server/service/extension/AbstractEventSourceService.java</p>"},{"location":"guide/writing-a-publishing-service-plugin/#1-implement-a-publishing-service","title":"1) Implement a publishing Service","text":"<p>Extend <code>AbstractEventSourceService&lt;T&gt;</code> to integrate with the event flow. Use <code>output.publish(event)</code> to emit events to all subscribers. Processors request subscription by calling <code>service.subscribe()</code>.</p> <pre><code>package com.fluxtion.server.example;\n\nimport com.fluxtion.server.service.extension.AbstractEventSourceService;\n\npublic class PublishingService extends AbstractEventSourceService&lt;String&gt; {\n\n    public PublishingService(String name) {\n        super(name);\n    }\n\n    // Publish an event to all subscribers\n    public void publish(String event) {\n        if (output != null) {\n            output.publish(event);\n        }\n    }\n}\n</code></pre> <p>Key points: - The service registers itself with the event flow when the server boots (via <code>setEventFlowManager</code> in the base class). - <code>subscribe()</code> uses the current ProcessorContext to add a subscription for the calling processor.</p>"},{"location":"guide/writing-a-publishing-service-plugin/#2-implement-a-processor-that-subscribes-via-serviceregistered","title":"2) Implement a processor that subscribes via @ServiceRegistered","text":"<p>Inject the service, call <code>subscribe()</code> in <code>start()</code>, and forward events to a sink in <code>handleEvent</code>.</p> <pre><code>package com.fluxtion.server.example;\n\nimport com.fluxtion.runtime.annotations.runtime.ServiceRegistered;\nimport com.fluxtion.runtime.node.ObjectEventHandlerNode;\nimport com.fluxtion.runtime.output.MessageSink;\n\npublic class PublishingServiceSubscriberHandler extends ObjectEventHandlerNode {\n\n    private PublishingService publishingService;\n    private MessageSink&lt;String&gt; sink;\n\n    @ServiceRegistered\n    public void wire(PublishingService service, String name) {\n        this.publishingService = service;\n    }\n\n    @ServiceRegistered\n    public void sink(MessageSink&lt;String&gt; sink, String name) {\n        this.sink = sink;\n    }\n\n    @Override\n    public void start() {\n        if (publishingService != null) {\n            publishingService.subscribe();\n        }\n    }\n\n    @Override\n    protected boolean handleEvent(Object event) {\n        if (event instanceof String s &amp;&amp; sink != null) {\n            sink.accept(s);\n        }\n        return true;\n    }\n}\n</code></pre> <p>Notes: - <code>@ServiceRegistered</code> injects services by type (and optionally name). - Calling <code>subscribe()</code> from <code>start()</code> ensures the processor is subscribed before events are published.</p>"},{"location":"guide/writing-a-publishing-service-plugin/#3-wire-and-run","title":"3) Wire and run","text":"<p>Create the service and processor, wire them into <code>AppConfig</code>, boot the server, then publish events.</p> <pre><code>import com.fluxtion.agrona.concurrent.BusySpinIdleStrategy;\nimport com.fluxtion.runtime.audit.LogRecordListener;\nimport com.fluxtion.runtime.output.MessageSink;\nimport com.fluxtion.server.FluxtionServer;\nimport com.fluxtion.server.config.*;\nimport com.fluxtion.server.connector.memory.InMemoryMessageSink;\n\n// Service and sink\nPublishingService pubService = new PublishingService(\"pubService\");\nInMemoryMessageSink memSink = new InMemoryMessageSink();\n\n// Processor that subscribes and forwards to sink\nPublishingServiceSubscriberHandler handler = new PublishingServiceSubscriberHandler();\n\nEventProcessorGroupConfig processorGroup = EventProcessorGroupConfig.builder()\n        .agentName(\"processor-agent\")\n        .put(\"subscriber-processor\", new EventProcessorConfig(handler))\n        .build();\n\nServiceConfig&lt;PublishingService&gt; svcCfg = ServiceConfig.&lt;PublishingService&gt;builder()\n        .service(pubService)\n        .serviceClass(PublishingService.class)\n        .name(\"pubService\")\n        .agent(\"service-agent\", new BusySpinIdleStrategy()) // optional: can omit to run without its own agent\n        .build();\n\nEventSinkConfig&lt;MessageSink&lt;?&gt;&gt; sinkCfg = EventSinkConfig.&lt;MessageSink&lt;?&gt;&gt;builder()\n        .instance(memSink)\n        .name(\"memSink\")\n        .build();\n\nAppConfig appConfig = AppConfig.builder()\n        .addProcessorGroup(processorGroup)\n        .addService(svcCfg)\n        .addEventSink(sinkCfg)\n        .build();\n\nLogRecordListener logListener = rec -&gt; {};\nFluxtionServer server = FluxtionServer.bootServer(appConfig, logListener);\n\n// Later: publish events via the service\npubService.publish(\"e1\");\npubService.publish(\"e2\");\n</code></pre> <p>The processor will receive these events via its <code>handleEvent</code> and forward them to the sink.</p>"},{"location":"guide/writing-a-publishing-service-plugin/#when-to-use-this-pattern","title":"When to use this pattern","text":"<ul> <li>You want a reusable service that can push events to processors on-demand (e.g., adapters, gateways, timers).</li> <li>Processors opt-in by calling <code>service.subscribe()</code> so the service receives a subscribe request from the processor.</li> <li>You want to leverage Fluxtion\u2019s event flow, backpressure, and dispatching while keeping a clean plugin boundary.</li> </ul>"},{"location":"guide/writing-a-service-plugin/","title":"Guide: Writing a Service Plugin for Fluxtion Server","text":"<p>This guide explains how to implement and integrate a custom Service into Fluxtion Server. A service is a component that is registered with the server and can participate in lifecycle management and dependency injection. Services can be simple (Lifecycle only) or worker/agent-hosted (with their own thread). They may also interact with the event flow when they implement specific interfaces, but a \u201cservice plugin\u201d here focuses on generic, reusable capabilities (admin, metrics, adaptors, utilities, HTTP clients/servers, etc.).</p> <p>You\u2019ll learn:</p> <ul> <li>When to write a service</li> <li>Implementing a simple Lifecycle service</li> <li>Implementing a worker (agent-hosted) service</li> <li>Dependency injection via <code>@ServiceRegistered</code></li> <li>Registering services via <code>ServiceConfig</code> and <code>AppConfig</code> (builder and programmatic)</li> <li>Naming, lookup, and interaction with other services</li> <li>Testing patterns and common pitfalls</li> </ul> <p>References in this repository:</p> <ul> <li><code>src/main/java/com/fluxtion/server/config/ServiceConfig.java</code></li> <li><code>src/main/java/com/fluxtion/server/internal/ServerConfigurator.java</code></li> <li><code>src/main/java/com/fluxtion/server/FluxtionServer.java</code></li> </ul>"},{"location":"guide/writing-a-service-plugin/#when-to-write-a-service","title":"When to write a service","text":"<p>Create a service when you need reusable functionality that should be lifecycle-managed and injectable across processors and other services. Typical use cases:</p> <ul> <li>Provide an admin or control API (e.g., register commands)</li> <li>Maintain shared state or caches available to multiple components</li> <li>Expose a client to external systems (HTTP/DB/KV) for processors to use</li> <li>Run background maintenance tasks or telemetry collection</li> </ul> <p>If the service needs to run continuously and perform periodic work, consider implementing it as a worker service ( agent-hosted). If it just exposes methods and reacts to calls, a simple <code>Lifecycle</code> service is sufficient.</p>"},{"location":"guide/writing-a-service-plugin/#simple-lifecycle-based-service-no-agent","title":"Simple Lifecycle-based service (no agent)","text":"<p>A basic service implements <code>com.fluxtion.runtime.lifecycle.Lifecycle</code> (optional but recommended). The server will call its lifecycle methods in order.</p> <pre><code>package com.mycompany.service;\n\nimport com.fluxtion.runtime.lifecycle.Lifecycle;\nimport lombok.extern.java.Log;\n\n@Log\npublic class MySimpleService implements Lifecycle {\n\n    private String configValue;\n\n    public MySimpleService(String configValue) {\n        this.configValue = configValue;\n    }\n\n    @Override\n    public void init() {\n        log.info(\"MySimpleService.init\");\n        // allocate light resources\n    }\n\n    @Override\n    public void start() {\n        log.info(\"MySimpleService.start\");\n        // open connections, prepare state\n    }\n\n    @Override\n    public void stop() {\n        log.info(\"MySimpleService.stop\");\n        // flush/close resources (idempotent)\n    }\n\n    @Override\n    public void tearDown() {\n        stop(); // ensure clean release\n    }\n\n    // Business methods other components can use\n    public String greet(String name) {\n        return \"Hello \" + name + \" with \" + configValue;\n    }\n}\n</code></pre>"},{"location":"guide/writing-a-service-plugin/#worker-agent-hosted-service","title":"Worker (agent-hosted) service","text":"<p>If your service needs its own thread to perform a periodic loop, implement <code>com.fluxtion.agrona.concurrent.Agent</code> (and optionally <code>Lifecycle</code>). Worker services are registered in an agent group with a chosen idle strategy.</p> <pre><code>package com.mycompany.service;\n\nimport com.fluxtion.agrona.concurrent.Agent;\nimport com.fluxtion.runtime.lifecycle.Lifecycle;\nimport lombok.extern.java.Log;\n\n@Log\npublic class MyWorkerService implements Agent, Lifecycle {\n\n    private volatile boolean running;\n    private long lastRunNs;\n    private long intervalNs = 50_000_000L; // 50ms\n\n    @Override\n    public void init() {\n        log.info(\"MyWorkerService.init\");\n    }\n\n    @Override\n    public void start() {\n        running = true;\n        lastRunNs = System.nanoTime();\n    }\n\n    @Override\n    public int doWork() {\n        // Non-blocking loop; return &gt;0 when work done to cooperate with idle strategy\n        long now = System.nanoTime();\n        if (now - lastRunNs &gt;= intervalNs) {\n            lastRunNs = now;\n            // perform periodic maintenance / flush / poll\n            return 1;\n        }\n        return 0;\n    }\n\n    @Override\n    public String roleName() {\n        return \"MyWorkerService\"; // used for diagnostics\n    }\n\n    @Override\n    public void stop() {\n        running = false;\n    }\n\n    @Override\n    public void tearDown() {\n        stop();\n    }\n}\n</code></pre> <p>Notes:</p> <ul> <li>Keep <code>doWork()</code> non-blocking; rely on the idle strategy to handle waiting.</li> <li>If you need IO, prefer time-bounded operations or non-blocking APIs.</li> </ul>"},{"location":"guide/writing-a-service-plugin/#dependency-injection-with-serviceregistered","title":"Dependency injection with @ServiceRegistered","text":"<p>Services can both inject and be injected into each other (and into processors) using the <code>@ServiceRegistered</code> annotation. The server performs reflective injection during <code>registerService</code>.</p> <pre><code>package com.mycompany.processor;\n\nimport com.fluxtion.runtime.annotations.runtime.ServiceRegistered;\nimport com.fluxtion.runtime.node.ObjectEventHandlerNode;\nimport com.mycompany.service.MySimpleService;\n\npublic class MyHandler extends ObjectEventHandlerNode {\n\n    private MySimpleService myService;\n\n    @ServiceRegistered\n    public void wire(MySimpleService myService, String name) {\n        // name is the registered service name\n        this.myService = myService;\n    }\n\n    @Override\n    protected boolean handleEvent(Object event) {\n        if (myService != null) {\n            String reply = myService.greet(String.valueOf(event));\n            System.out.println(\"Processed: \" + reply);\n        }\n        return true;\n    }\n}\n</code></pre> <p>Key points:</p> <ul> <li>The <code>@ServiceRegistered</code> method can accept the service instance and optionally the service name.</li> <li>Server injects newly registered services into all existing services and vice versa (single-target injection step),   enabling loose coupling.</li> </ul>"},{"location":"guide/writing-a-service-plugin/#registering-services-with-appconfig-fluent-builder","title":"Registering services with AppConfig (fluent builder)","text":"<p>Register services using <code>ServiceConfig</code>. For worker services, specify an agent group and an idle strategy.</p> <pre><code>import com.fluxtion.agrona.concurrent.BusySpinIdleStrategy;\nimport com.fluxtion.server.config.AppConfig;\nimport com.fluxtion.server.config.ServiceConfig;\n\nMySimpleService simple = new MySimpleService(\"cfgA\");\nMyWorkerService worker = new MyWorkerService();\n\nServiceConfig&lt;MySimpleService&gt; simpleCfg = ServiceConfig.&lt;MySimpleService&gt;builder()\n        .service(simple)\n        .serviceClass(MySimpleService.class)\n        .name(\"simpleService\")\n        .build();\n\nServiceConfig&lt;MyWorkerService&gt; workerCfg = ServiceConfig.&lt;MyWorkerService&gt;builder()\n        .service(worker)\n        .serviceClass(MyWorkerService.class)\n        .name(\"workerService\")\n        .agent(\"worker-agent-group\", new BusySpinIdleStrategy())\n        .build();\n\nAppConfig app = AppConfig.builder()\n        .addService(simpleCfg)\n        .addService(workerCfg)\n        .build();\n</code></pre> <p>When booting the server with this <code>AppConfig</code>, <code>ServerConfigurator</code> will:</p> <ul> <li>Register the simple service (as a regular <code>Service</code>)</li> <li>Register the worker service (as a <code>ServiceAgent</code> with the given agent group and idle strategy)</li> <li>Perform dependency injection between all registered services and processors</li> </ul>"},{"location":"guide/writing-a-service-plugin/#programmatic-boot-and-lookup","title":"Programmatic boot and lookup","text":"<p>You can also boot programmatically and inspect the registered services map.</p> <pre><code>import com.fluxtion.runtime.audit.LogRecordListener;\nimport com.fluxtion.server.FluxtionServer;\n\nLogRecordListener logs = rec -&gt; {};\nFluxtionServer server = FluxtionServer.bootServer(app, logs);\n\ntry {\n    var registry = server.registeredServices();\n    var simpleSvc = registry.get(\"simpleService\");\n    Object instance = simpleSvc.instance();\n    // cast and use\n} finally {\n    server.stop();\n}\n</code></pre> <p>You may also boot from YAML using <code>FluxtionServer.bootServer(Reader, LogRecordListener)</code>; YAML maps directly to <code>AppConfig</code> and <code>ServiceConfig</code> fields.</p>"},{"location":"guide/writing-a-service-plugin/#worker-services-and-agent-threads","title":"Worker services and agent threads","text":"<ul> <li>A worker service must implement <code>com.fluxtion.agrona.concurrent.Agent</code>.</li> <li>In <code>ServiceConfig</code>, set <code>agent(groupName, idleStrategy)</code> to host it in a runner thread.</li> <li>The server selects an idle strategy using <code>AppConfig.getIdleStrategyOrDefault(...)</code> when necessary; per-group   overrides are supported via <code>AppConfig.agentThreads</code>.</li> </ul>"},{"location":"guide/writing-a-service-plugin/#testing-your-service","title":"Testing your service","text":"<ul> <li>Unit-test simple services by constructing them directly and calling lifecycle methods in order (<code>init</code>, <code>start</code>,   <code>stop</code>, <code>tearDown</code>).</li> <li>For worker services, test the <code>doWork()</code> loop logic in isolation; avoid real sleeping; simulate time or use small   intervals.</li> <li>For integration tests with the server: build a small <code>AppConfig</code>, boot the server, and verify injection and   interactions work.</li> </ul> <p>Example test snippet for a simple service:</p> <pre><code>MySimpleService svc = new MySimpleService(\"cfg\");\nsvc.init();\nsvc.start();\nString out = svc.greet(\"Alice\");\norg.junit.jupiter.api.Assertions.assertTrue(out.contains(\"Alice\"));\nsvc.stop();\nsvc.tearDown();\n</code></pre>"},{"location":"guide/writing-a-service-plugin/#common-pitfalls-and-tips","title":"Common pitfalls and tips","text":"<ul> <li>Make <code>stop()</code> idempotent; always close resources.</li> <li>Avoid long blocking in <code>Agent#doWork()</code>; keep it non-blocking with bounded work per call.</li> <li>Guard logs in hot paths using <code>log.isLoggable(...)</code> to reduce overhead.</li> <li>Provide clear service names in <code>ServiceConfig</code> for easier injection and debugging.</li> <li>If your service also participates in event flow (implements <code>EventFlowService</code>), the server will wire it to the   <code>EventFlowManager</code> automatically during registration.</li> </ul>"},{"location":"guide/writing-a-service-plugin/#see-also","title":"See also","text":"<ul> <li>Message sinks: Writing a Message Sink Plugin</li> <li>Event sources: Writing an Event Source Plugin</li> <li>Configuration API: ServiceConfig.java,   <code>AppConfig.Builder</code></li> <li>Bootstrapping: ServerConfigurator.java,   <code>FluxtionServer</code></li> </ul>"},{"location":"guide/writing-a-typed-invoke-publishing-service-plugin/","title":"How to write a publishing Service plugin that uses a typed invoke strategy","text":"<p>This guide extends the basic publishing service example by delivering events via a strongly-typed interface on the event processor. Instead of always calling onEvent(Object), the service configures a custom EventToInvokeStrategy and a CallBackType bound to an interface. Only processors that implement that interface will be targeted, and the strategy invokes the typed method.</p> <p>What you will learn: - Define a listener interface that processors can implement (e.g., PublishingServiceListener) - Configure a service to use CallBackType.forClass(PublishingServiceListener.class) - Provide an EventToInvokeStrategy that calls listener.onServiceEvent(String) - Subscribe from the processor via @ServiceRegistered and service.subscribe()</p> <p>References in this repository: - Typed service: src/test/java/com/fluxtion/server/example/PublishingServiceTyped.java - Listener interface: src/test/java/com/fluxtion/server/example/PublishingServiceListener.java - Typed processor: src/test/java/com/fluxtion/server/example/PublishingServiceTypedSubscriberHandler.java - End-to-end test: src/test/java/com/fluxtion/server/example/PublishingServiceTypedInvokeExampleTest.java - Base service support: src/main/java/com/fluxtion/server/service/extension/AbstractEventSourceService.java</p>"},{"location":"guide/writing-a-typed-invoke-publishing-service-plugin/#1-define-a-listener-interface","title":"1) Define a listener interface","text":"<pre><code>package com.fluxtion.server.example;\n\npublic interface PublishingServiceListener {\n    void onServiceEvent(String event);\n}\n</code></pre>"},{"location":"guide/writing-a-typed-invoke-publishing-service-plugin/#2-implement-a-typed-publishing-service","title":"2) Implement a typed publishing service","text":"<p>Extend AbstractEventSourceService and configure: - CallBackType.forClass(PublishingServiceListener.class) as the callback type - A supplier of a custom EventToInvokeStrategy that calls the typed method <pre><code>package com.fluxtion.server.example;\n\nimport com.fluxtion.server.dispatch.AbstractEventToInvocationStrategy;\nimport com.fluxtion.server.service.CallBackType;\nimport com.fluxtion.server.service.extension.AbstractEventSourceService;\nimport com.fluxtion.runtime.StaticEventProcessor;\n\npublic class PublishingServiceTyped extends AbstractEventSourceService&lt;String&gt; {\n\n    public PublishingServiceTyped(String name) {\n        super(name,\n                CallBackType.forClass(PublishingServiceListener.class),\n                TypedInvokeStrategy::new);\n    }\n\n    public void publish(String event) {\n        if (output != null) {\n            output.publish(event);\n        }\n    }\n\n    static class TypedInvokeStrategy extends AbstractEventToInvocationStrategy {\n        @Override\n        protected void dispatchEvent(Object event, StaticEventProcessor eventProcessor) {\n            if (eventProcessor instanceof PublishingServiceListener listener &amp;&amp; event instanceof String s) {\n                listener.onServiceEvent(s);\n            } else {\n                eventProcessor.onEvent(event);\n            }\n        }\n\n        @Override\n        protected boolean isValidTarget(StaticEventProcessor eventProcessor) {\n            return eventProcessor instanceof PublishingServiceListener;\n        }\n    }\n}\n</code></pre>"},{"location":"guide/writing-a-typed-invoke-publishing-service-plugin/#3-implement-a-processor-that-subscribes-and-implements-the-listener","title":"3) Implement a processor that subscribes and implements the listener","text":"<pre><code>package com.fluxtion.server.example;\n\nimport com.fluxtion.runtime.DefaultEventProcessor;\nimport com.fluxtion.runtime.annotations.runtime.ServiceRegistered;\nimport com.fluxtion.runtime.node.ObjectEventHandlerNode;\nimport com.fluxtion.runtime.output.MessageSink;\n\npublic class PublishingServiceTypedSubscriberHandler extends DefaultEventProcessor\n        implements PublishingServiceListener {\n\n    private final TypedHandler typedHandler;\n\n    public PublishingServiceTypedSubscriberHandler(TypedHandler typedHandler) {\n        super(typedHandler);\n        this.typedHandler = typedHandler;\n    }\n\n    @Override\n    public void onServiceEvent(String event) {\n        typedHandler.onServiceEvent(event);\n    }\n\n    public static class TypedHandler extends ObjectEventHandlerNode implements PublishingServiceListener {\n\n        private PublishingServiceTyped service;\n        private MessageSink&lt;String&gt; sink;\n\n        @ServiceRegistered\n        public void wire(PublishingServiceTyped service, String name) {\n            this.service = service;\n        }\n\n        @ServiceRegistered\n        public void sink(MessageSink&lt;String&gt; sink, String name) {\n            this.sink = sink;\n        }\n\n        @Override\n        public void start() {\n            if (service != null) {\n                service.subscribe();\n            }\n        }\n\n        @Override\n        public void tearDown() {\n            // No-op\n        }\n\n        @Override\n        public void onServiceEvent(String event) {\n            if (sink != null) {\n                sink.accept(event);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"guide/writing-a-typed-invoke-publishing-service-plugin/#4-wire-and-test","title":"4) Wire and test","text":"<p>The test boots a server, registers the typed service and a processor that implements the listener, then publishes events:</p> <pre><code>PublishingServiceTyped pubService = new PublishingServiceTyped(\"pubServiceTyped\");\nPublishingServiceTypedSubscriberHandler handler = new PublishingServiceTypedSubscriberHandler(new PublishingServiceTypedSubscriberHandler.TypedHandler());\n\nEventProcessorGroupConfig processorGroup = EventProcessorGroupConfig.builder()\n        .agentName(\"processor-agent\")\n        .put(\"typed-subscriber-processor\", EventProcessorConfig.builder().handler(handler).build())\n        .build();\n\nServiceConfig&lt;PublishingServiceTyped&gt; svcCfg = ServiceConfig.&lt;PublishingServiceTyped&gt;builder()\n        .service(pubService)\n        .serviceClass(PublishingServiceTyped.class)\n        .name(\"pubServiceTyped\")\n        //.agent(\"service-agent\", new BusySpinIdleStrategy()) // optional: uncomment to give the service its own agent\n        .build();\n\nAppConfig appConfig = AppConfig.builder()\n        .addProcessorGroup(processorGroup)\n        .addService(svcCfg)\n        .build();\n\nFluxtionServer server = FluxtionServer.bootServer(appConfig, rec -&gt; {});\n\npubService.publish(\"t1\");\npubService.publish(\"t2\");\n</code></pre> <p>The processor receives these via onServiceEvent and can forward them to a sink.</p>"},{"location":"guide/writing-a-typed-invoke-publishing-service-plugin/#why-use-typed-invokes","title":"Why use typed invokes?","text":"<ul> <li>Explicit contracts between service and processor via an interface</li> <li>Compile-time safety for callback signatures</li> <li>Ability to filter eligible processors by interface</li> <li>Coexists with onEvent fallback if desired</li> </ul>"},{"location":"guide/writing-an-admin-command/","title":"Guide: Writing an Admin Command for Fluxtion Server","text":"<p>This guide explains how to add operational/admin commands to your Fluxtion Server application. Admin commands are lightweight functions that you register at runtime and can invoke via a CLI or programmatically to inspect or control the system (list services, stop processors, flush caches, custom health checks, etc.).</p> <p>You\u2019ll learn:</p> <ul> <li>What the AdminCommand API is and how it works</li> <li>How to register commands from processors and services using AdminCommandRegistry</li> <li>Command function signature, arguments, and output/error channels</li> <li>How commands are dispatched through the event flow (asynchronously) or executed directly</li> <li>How to invoke commands from a CLI or programmatically</li> <li>Tips, patterns, and references in this repository</li> </ul>"},{"location":"guide/writing-an-admin-command/#key-types","title":"Key types","text":"<ul> <li>AdminCommandRegistry \u2014 central registry to add and invoke commands<ul> <li>package: <code>com.fluxtion.server.service.admin</code></li> </ul> </li> <li>AdminFunction \u2014 your command function signature<ul> <li><code>void processAdminCommand(List&lt;String&gt; args, Consumer&lt;OUT&gt; out, Consumer&lt;ERR&gt; err)</code></li> </ul> <li>AdminCommandRequest \u2014 DTO for programmatic invocation (name, args, output consumers)</li> <li>AdminCommandProcessor \u2014 service that routes commands through the event flow and hosts built-ins (   help/commands/eventSources)</li> <li>CliAdminCommandProcessor \u2014 optional interactive console to type commands</li> <li>FluxtionServerAdmin \u2014 sample \u201cserver control\u201d commands (list services/processors, stop processors)</li> <p>References:</p> <ul> <li>AdminCommandRegistry.java</li> <li>AdminFunction.java</li> <li>AdminCommandRequest.java</li> <li>AdminCommandProcessor.java</li> <li>CliAdminCommandProcessor.java</li> <li>FluxtionServerAdmin.java</li> </ul>"},{"location":"guide/writing-an-admin-command/#how-it-works","title":"How it works","text":"<p>At startup you register an AdminCommandProcessor as a service. Other services and processors can inject the AdminCommandRegistry (via @ServiceRegistered) and register commands. When a command is invoked:</p> <ul> <li>If the registering component was an event processor (i.e., currentProcessor present during registration), the command   is wired to publish into that processor\u2019s input queue as an AdminCommand event, which is executed by   AdminCommandInvoker on the processor\u2019s agent thread (asynchronous, back\u2011pressure aware).</li> <li>If registered outside a processor context (e.g., a plain service at init/start time), the command executes directly in   the caller thread.</li> </ul> <p>This lets you choose between async delivery into a processor\u2019s single-threaded context, or immediate synchronous execution.</p>"},{"location":"guide/writing-an-admin-command/#registering-a-command","title":"Registering a command","text":"<p>Register from a processor or a service using @ServiceRegistered to obtain the registry.</p> <p>Example (from a processor):</p> <pre><code>package com.mycompany.ops;\n\nimport com.fluxtion.runtime.annotations.runtime.ServiceRegistered;\nimport com.fluxtion.runtime.node.ObjectEventHandlerNode;\nimport com.fluxtion.server.service.admin.AdminCommandRegistry;\n\nimport java.util.List;\nimport java.util.function.Consumer;\n\npublic class OpsHandler extends ObjectEventHandlerNode {\n\n    @ServiceRegistered\n    public void registerAdmin(AdminCommandRegistry admin, String name) {\n        // name is the AdminCommandRegistry service name\n        admin.registerCommand(\"ops.ping\", this::ping);\n        admin.registerCommand(\"ops.echo\", this::echo);\n    }\n\n    private void ping(List&lt;String&gt; args, Consumer&lt;Object&gt; out, Consumer&lt;Object&gt; err) {\n        out.accept(\"pong\");\n    }\n\n    private void echo(List&lt;String&gt; args, Consumer&lt;Object&gt; out, Consumer&lt;Object&gt; err) {\n        // args[0] is the command name, args[1..] are user args\n        out.accept(String.join(\" \", args));\n    }\n}\n</code></pre> <p>Example (from a service):</p> <pre><code>public class OpsService implements com.fluxtion.runtime.lifecycle.Lifecycle {\n    private com.fluxtion.server.service.admin.AdminCommandRegistry registry;\n\n    @com.fluxtion.runtime.annotations.runtime.ServiceRegistered\n    public void admin(AdminCommandRegistry registry) { this.registry = registry; }\n\n    @Override public void start() {\n        registry.registerCommand(\"ops.time\", (args, out, err) -&gt; out.accept(java.time.Instant.now().toString()));\n    }\n\n    @Override public void init() {}\n    @Override public void stop() {}\n    @Override public void tearDown() {}\n}\n</code></pre>"},{"location":"guide/writing-an-admin-command/#wiring-admin-infrastructure-in-appconfig","title":"Wiring admin infrastructure in AppConfig","text":"<p>You need to register the admin services in your application.</p> <pre><code>import com.fluxtion.server.config.AppConfig;\nimport com.fluxtion.server.config.ServiceConfig;\nimport com.fluxtion.server.service.admin.AdminCommandRegistry;\nimport com.fluxtion.server.service.admin.impl.AdminCommandProcessor;\nimport com.fluxtion.server.service.admin.impl.CliAdminCommandProcessor;\n\n// Admin registry/dispatcher service\nServiceConfig&lt;AdminCommandRegistry&gt; adminSvc = ServiceConfig.&lt;AdminCommandRegistry&gt;builder()\n        .service(new AdminCommandProcessor())\n        .serviceClass(AdminCommandRegistry.class)\n        .name(\"adminService\")\n        .build();\n\n// Optional: interactive CLI running on the JVM stdin/stdout\nServiceConfig&lt;?&gt; cliSvc = ServiceConfig.builder()\n        .service(new CliAdminCommandProcessor())\n        .name(\"adminCli\")\n        .build();\n\nAppConfig app = AppConfig.builder()\n        // add your processors and other services...\n        .addService(adminSvc)\n        .addService(cliSvc)  // optional\n        .build();\n</code></pre> <p>Notes:</p> <ul> <li>AdminCommandProcessor exposes default commands: <code>help</code>, <code>?</code>, <code>commands</code>, <code>eventSources</code>.</li> <li>FluxtionServerAdmin registers higher-level server operations (list services/processors, stop processors). To use it:</li> </ul> <pre><code>ServiceConfig&lt;?&gt; serverAdmin = ServiceConfig.builder()\n        .service(new com.fluxtion.server.service.servercontrol.FluxtionServerAdmin())\n        .name(\"serverAdmin\")\n        .build();\n\napp = AppConfig.builder()\n        // ...\n        .addService(adminSvc)\n        .addService(serverAdmin)\n        .build();\n</code></pre>"},{"location":"guide/writing-an-admin-command/#invoking-a-command","title":"Invoking a command","text":"<p>There are two common ways:</p> <p>1) From the CLI (if CliAdminCommandProcessor is registered)</p> <ul> <li>At runtime type: <code>commands</code> to list available commands</li> <li>Example: <code>server.processors.list</code></li> <li>Example: <code>ops.echo hello world</code></li> </ul> <p>2) Programmatically using AdminCommandRegistry</p> <pre><code>import com.fluxtion.server.service.admin.AdminCommandRequest;\n\nvar request = new AdminCommandRequest();\nrequest.setCommand(\"ops.echo\");\nrequest.setArguments(java.util.List.of(\"hello\", \"world\"));\nrequest.setOutput(System.out::println);\nrequest.setErrOutput(System.err::println);\n\n// obtain the registry from FluxtionServer.registeredServices()\ncom.fluxtion.runtime.service.Service&lt;?&gt; svc = server.registeredServices().get(\"adminService\");\ncom.fluxtion.server.service.admin.AdminCommandRegistry registry =\n        (com.fluxtion.server.service.admin.AdminCommandRegistry) svc.instance();\n\nregistry.processAdminCommandRequest(request);\n</code></pre> <p>What happens under the hood:</p> <ul> <li>The AdminCommandProcessor looks up your registered command. If it was registered inside a processor context, it   publishes an AdminCommand event into that processor\u2019s input queue and the AdminCommandInvoker executes it on the   processor\u2019s agent thread. Otherwise, it executes immediately in the caller thread.</li> </ul>"},{"location":"guide/writing-an-admin-command/#command-function-signature-and-args","title":"Command function signature and args","text":"<p>Your command implements:</p> <pre><code>void processAdminCommand(List&lt;String&gt; args, Consumer&lt;OUT&gt; out, Consumer&lt;ERR&gt; err)\n</code></pre> <ul> <li>args contains the full tokenized input including the command name at index 0 (e.g., [\"ops.echo\", \"hello\", \"world\"]).</li> <li>Use <code>out.accept(...)</code> for normal output, <code>err.accept(...)</code> for warnings/errors.</li> <li>Prefer short, dash\u2011separated names (e.g., <code>cache.clear</code>, <code>server.service.list</code>).</li> </ul>"},{"location":"guide/writing-an-admin-command/#tips-and-patterns","title":"Tips and patterns","text":"<ul> <li>Keep commands small and fast. If you need to run in a processor context, the infrastructure will deliver your command   asynchronously to that single\u2011threaded agent.</li> <li>Validate args and produce helpful <code>err</code> messages; don\u2019t throw unless exceptional.</li> <li>For long operations, consider returning a quick acknowledgement and performing the work asynchronously; stream   progress to <code>out</code> if appropriate.</li> <li>Use <code>commands</code> and <code>help</code> to explore what\u2019s registered at runtime.</li> <li>Combine with FluxtionServerAdmin for common operational tasks.</li> </ul>"},{"location":"guide/writing-an-admin-command/#example-endtoend","title":"Example end\u2011to\u2011end","text":"<p>See:</p> <ul> <li>BroadcastCallbackTest.java</li> <li>FluxtionServerAdmin.java   These show wiring the admin registry, adding commands, and optional CLI usage.</li> </ul>"},{"location":"guide/writing-an-event-source-plugin/","title":"Guide: Writing an Event Source Plugin for Fluxtion Server","text":"<p>This guide explains how to implement a custom event source (input connector) that publishes events into Fluxtion Server\u2019s event flow. You will learn how to:</p> <ul> <li>Choose the right base class for your source</li> <li>Implement lifecycle and (optionally) agent work loops</li> <li>Publish events safely and efficiently (with optional pre-start caching)</li> <li>Configure wrapping, slow-consumer strategy, and data mapping</li> <li>Register your source with AppConfig via EventFeedConfig</li> <li>Test your event source</li> </ul> <p>Reference implementations in this repository:</p> <ul> <li>File-based source: FileEventSource.java</li> <li>In-memory   source: InMemoryEventSource.java</li> <li>Base   classes: AbstractEventSourceService.java   and AbstractAgentHostedEventSourceService.java</li> </ul>"},{"location":"guide/writing-an-event-source-plugin/#when-to-write-a-source","title":"When to write a source","text":"<p>Create a custom source when events originate outside your processors and must be injected into the server, e.g.:</p> <ul> <li>Tail a file, read a socket/HTTP stream, consume from Kafka/JMS/MQTT, poll a DB, integrate a custom driver, etc.</li> </ul> <p>If your source needs its own thread and a non-blocking work loop, implement an agent-hosted source. If events are pushed from an external library callback (and you don\u2019t need your own loop), a non-agent source may be sufficient.</p>"},{"location":"guide/writing-an-event-source-plugin/#pick-a-base-class","title":"Pick a base class","text":"<ul> <li> <p>AbstractEventSourceService <ul> <li>Use when your source does not need an Agrona Agent; e.g., you receive callbacks from another component and can   forward to Fluxtion.</li> <li>You get lifecycle hooks (init/start/stop/tearDown) and are wired into the event flow.</li> </ul> <li> <p>AbstractAgentHostedEventSourceService <ul> <li>Extends AbstractEventSourceService and implements com.fluxtion.agrona.concurrent.Agent.</li> <li>Use when your source runs its own work loop (doWork), like file tailing, network reads, or periodic polling.</li> <li>Provides roleName() for agent diagnostics.</li> </ul> <p>Both base classes take care of registration with the EventFlowManager and provide an EventToQueuePublisher named output you use to publish events."},{"location":"guide/writing-an-event-source-plugin/#lifecycle-and-publishing","title":"Lifecycle and publishing","text":"<p>Typical lifecycle flow:</p> <ul> <li>init(): light setup</li> <li>start(): allocate IO/resources, set up caching or state</li> <li>startComplete(): server signals that the system is ready; you may switch from caching to publishing and replay cached   events</li> <li>doWork(): agent loop (only for agent-hosted sources)</li> <li>stop()/tearDown(): release resources</li> </ul> <p>Publishing APIs available via this.output:</p> <ul> <li>output.publish(item): map (via dataMapper) and dispatch immediately to subscribed queues</li> <li>output.cache(item): record in the event log cache but do not dispatch yet</li> <li>output.setCacheEventLog(boolean): enable/disable event log caching</li> <li>output.dispatchCachedEventLog(): dispatch any cached events to queues (useful at startComplete)</li> <li>output.getEventLog(): snapshot of NamedFeedEvent entries when caching is enabled</li> </ul> <p>Wrapping and mapping are applied at dispatch time by EventToQueuePublisher.</p>"},{"location":"guide/writing-an-event-source-plugin/#minimal-agent-hosted-source-skeleton","title":"Minimal agent-hosted source (skeleton)","text":"<pre><code>package com.mycompany.source;\n\nimport com.fluxtion.runtime.event.NamedFeedEvent;\nimport com.fluxtion.server.service.extension.AbstractAgentHostedEventSourceService;\nimport lombok.extern.java.Log;\n\nimport java.util.List;\n\n@Log\npublic class MyAgentSource extends AbstractAgentHostedEventSourceService&lt;Object&gt; {\n\n    private boolean publishToQueue;\n\n    public MyAgentSource() {\n        super(\"myAgentSource\");\n    }\n\n    @Override\n    public void start() {\n        // Enable pre-start caching if you need to read historic/backlog before serving live\n        output.setCacheEventLog(true); // optional\n        publishToQueue = false;        // cache until startComplete\n        // Open resources (files, sockets, clients) here\n    }\n\n    @Override\n    public void startComplete() {\n        publishToQueue = true;\n        // Replay cached data once the system is ready\n        output.dispatchCachedEventLog();\n    }\n\n    @Override\n    public int doWork() throws Exception {\n        int work = 0;\n        // 1) Read or poll your data source\n        Object next = readNextOrNull();\n        while (next != null) {\n            if (publishToQueue) {\n                output.publish(next);\n            } else {\n                output.cache(next);\n            }\n            work++;\n            next = readNextOrNull();\n        }\n        return work;\n    }\n\n    private Object readNextOrNull() {\n        // TODO: implement a non-blocking read that returns null when no data is available\n        return null;\n    }\n\n    @Override\n    public void stop() {\n        // Close resources\n    }\n\n    @Override\n    public &lt;T&gt; NamedFeedEvent&lt;T&gt;[] eventLog() {\n        List&lt;com.fluxtion.runtime.event.NamedFeedEvent&gt; log = (List) output.getEventLog();\n        return log.toArray(new NamedFeedEvent[0]);\n    }\n}\n</code></pre>"},{"location":"guide/writing-an-event-source-plugin/#minimal-non-agent-source-callback-driven","title":"Minimal non-agent source (callback-driven)","text":"<pre><code>package com.mycompany.source;\n\nimport com.fluxtion.server.service.extension.AbstractEventSourceService;\n\npublic class MyCallbackSource extends AbstractEventSourceService&lt;String&gt; {\n\n    private boolean publishToQueue;\n\n    public MyCallbackSource() {\n        super(\"myCallbackSource\");\n    }\n\n    @Override\n    public void start() {\n        // If you expect callbacks to start arriving before the server is fully ready\n        output.setCacheEventLog(true);\n        publishToQueue = false;\n        // Register your external callbacks here, e.g., client.onMessage(this::onData)\n    }\n\n    @Override\n    public void startComplete() {\n        publishToQueue = true;\n        output.dispatchCachedEventLog();\n    }\n\n    // Example external callback\n    public void onData(String value) {\n        if (publishToQueue) {\n            output.publish(value);\n        } else {\n            output.cache(value);\n        }\n    }\n}\n</code></pre>"},{"location":"guide/writing-an-event-source-plugin/#event-wrapping-slow-consumer-policy-and-data-mapping","title":"Event wrapping, slow-consumer policy, and data mapping","text":"<p>Event wrapping determines how items are written to queues:</p> <ul> <li>SUBSCRIPTION_NOWRAP: publish raw mapped item only to subscribed processors</li> <li>SUBSCRIPTION_NAMED_EVENT: wrap in NamedFeedEvent for subscribers (default in EventFeedConfig)</li> <li>BROADCAST_NOWRAP / BROADCAST_NAMED_EVENT: deliver to all handlers regardless of subscription</li> </ul> <p>Slow-consumer policy hints (currently managed internally):</p> <ul> <li>BACKOFF (default) \u2014 used by EventToQueuePublisher to avoid long blocking on contended queues</li> </ul> <p>Data mapping lets you transform T-&gt;U before dispatch (e.g., parse lines, decode bytes):</p> <ul> <li>In code: setDataMapper(Function) <li>Via config builder: EventFeedConfig.Builder#valueMapper</li>"},{"location":"guide/writing-an-event-source-plugin/#register-your-source-with-appconfig","title":"Register your source with AppConfig","text":"<p>Use EventFeedConfig to add your source, control wrapping/broadcast, and optionally host it on an agent thread.</p> <pre><code>import com.fluxtion.agrona.concurrent.BusySpinIdleStrategy;\nimport com.fluxtion.server.config.AppConfig;\nimport com.fluxtion.server.config.EventFeedConfig;\n\nMyAgentSource src = new MyAgentSource();\n\nEventFeedConfig&lt;?&gt; feed = EventFeedConfig.builder()\n        .instance(src)\n        .name(\"myFeed\")\n        .broadcast(true)                 // or false\n        .wrapWithNamedEvent(true)        // often preferred for auditing/metadata\n        .agent(\"my-source-agent\", new BusySpinIdleStrategy()) // required if source is Agent-hosted\n        .build();\n\nAppConfig app = AppConfig.builder()\n        .addEventFeed(feed)\n        .build();\n</code></pre> <p>Notes:</p> <ul> <li>If your source implements Agent (i.e., extends AbstractAgentHostedEventSourceService), supply agent(name,   idleStrategy) in EventFeedConfig.</li> <li>If it\u2019s not agent-hosted, omit the agent() call.</li> </ul> <p>Under the hood, ServerConfigurator will translate your EventFeedConfig into a Service or ServiceAgent and register it with FluxtionServer. During registration, AbstractEventSourceService wires itself to the EventFlowManager and prepares the EventToQueuePublisher output.</p>"},{"location":"guide/writing-an-event-source-plugin/#pre-start-caching-pattern","title":"Pre-start caching pattern","text":"<p>If you need to read an initial backlog before serving live (or avoid dropping events during server startup):</p> <ul> <li>Call output.setCacheEventLog(true) in start()</li> <li>Cache(events) until startComplete()</li> <li>On startComplete(), set a flag to publish and call output.dispatchCachedEventLog()</li> </ul> <p>This pattern is used by FileEventSource and InMemoryEventSource in this repo.</p>"},{"location":"guide/writing-an-event-source-plugin/#testing-your-source","title":"Testing your source","text":"<ul> <li>Unit test the doWork() loop (for agent-hosted) or the callback path (for non-agent).</li> <li>Inject a test EventToQueuePublisher and a OneToOneConcurrentArrayQueue as the target queue; drain and assert outputs.</li> <li>Verify event log when caching is enabled via output.getEventLog().</li> <li>See src/test/java/com/fluxtion/server/connector/file/FileEventSourceTest.java and   src/test/java/com/fluxtion/server/connector/memory/InMemoryEventSourceTest.java for patterns.</li> </ul> <p>Example snippet:</p> <pre><code>EventToQueuePublisher&lt;String&gt; pub = new EventToQueuePublisher&lt;&gt;(\"myFeed\");\nOneToOneConcurrentArrayQueue&lt;Object&gt; q = new OneToOneConcurrentArrayQueue&lt;&gt;(128);\npub.addTargetQueue(q, \"out\");\nmySource.setOutput(pub); // add a package-private setter in tests if needed\n\nmySource.start();\nmySource.startComplete();\nmySource.offer(\"x\");\nmySource.doWork();\n\nList&lt;Object&gt; drained = new ArrayList&lt;&gt;();\nq.drainTo(drained, 10);\nassertEquals(List.of(\"x\"), drained.stream().map(Object::toString).toList());\n</code></pre>"},{"location":"guide/writing-an-event-source-plugin/#tips-and-pitfalls","title":"Tips and pitfalls","text":"<ul> <li>Avoid blocking indefinitely in doWork(); use non-blocking reads or time-bounded IO. Let the agent idle strategy handle   waits.</li> <li>Guard logging in hot paths (use log.isLoggable) to avoid overhead.</li> <li>Keep data mapping simple and resilient; report mapping errors via the built-in error reporting when appropriate (   EventToQueuePublisher logs mapping errors).</li> <li>Ensure stop() is idempotent and always closes resources.</li> <li>For file-like sources, consider read strategies (earliest, committed, latest); see FileEventSource for an example   approach.</li> </ul>"},{"location":"guide/writing-an-event-source-plugin/#see-also","title":"See also","text":"<ul> <li>FileEventSource.java   and InMemoryEventSource.java for   complete, working examples</li> <li>docs/guide/file-and-memory-feeds-example.md for end-to-end wiring with processors   and sinks</li> <li>AbstractEventSourceService, AbstractAgentHostedEventSourceService   for lifecycle and wiring details</li> </ul>"},{"location":"standards/coding-standards/","title":"Fluxtion Server Coding Standards and Best Practices","text":""},{"location":"standards/coding-standards/#introduction","title":"Introduction","text":"<p>This document outlines the coding standards and best practices for the Fluxtion Server project. Following these standards ensures consistency across the codebase, improves code quality, and makes the codebase more maintainable.</p>"},{"location":"standards/coding-standards/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Code Style and Formatting</li> <li>Naming Conventions</li> <li>Documentation Standards</li> <li>Error Handling</li> <li>Logging</li> <li>Testing</li> <li>Performance Considerations</li> <li>Security Best Practices</li> <li>Code Organization</li> <li>Dependency Management</li> </ol>"},{"location":"standards/coding-standards/#code-style-and-formatting","title":"Code Style and Formatting","text":""},{"location":"standards/coding-standards/#file-structure","title":"File Structure","text":"<p>Each Java file should follow this structure:</p> <ol> <li>License header</li> <li>Package declaration</li> <li>Import statements (organized and grouped)</li> <li>Class/interface declaration with Javadoc</li> <li>Constants</li> <li>Fields</li> <li>Constructors</li> <li>Methods</li> <li>Inner classes/interfaces</li> </ol> <p>Example:</p> <pre><code>/*\n * SPDX-FileCopyrightText: \u00a9 2025 Gregory Higgins &lt;greg.higgins@v12technology.com&gt;\n * SPDX-License-Identifier: AGPL-3.0-only\n */\n\npackage com.fluxtion.server.example;\n\nimport java.util.List;\nimport java.util.Map;\n\nimport com.fluxtion.runtime.annotations.OnEvent;\nimport com.fluxtion.server.config.ConfigMap;\n\n/**\n * Example class demonstrating the file structure.\n */\npublic class ExampleClass {\n\n    public static final String CONSTANT_VALUE = \"value\";\n\n    private final String field;\n    private Map&lt;String, Object&gt; configMap;\n\n    public ExampleClass(String field) {\n        this.field = field;\n    }\n\n    public void processEvent(Object event) {\n        // Method implementation\n    }\n\n    private class InnerClass {\n        // Inner class implementation\n    }\n}\n</code></pre>"},{"location":"standards/coding-standards/#indentation-and-line-wrapping","title":"Indentation and Line Wrapping","text":"<ul> <li>Use 4 spaces for indentation, not tabs</li> <li>Maximum line length should be 120 characters</li> <li>When wrapping lines, indent continuation lines by 8 spaces</li> <li>Method chaining should align dots on new lines</li> </ul> <p>Example:</p> <pre><code>// Good - proper indentation and line wrapping\npublic void methodWithLongSignature(String parameter1, String parameter2,\n        int parameter3, Map&lt;String, Object&gt; parameter4) {\n    // Method implementation\n}\n\n// Good - method chaining with aligned dots\neventProcessor.setAuditLogProcessor(logRecordListener)\n              .setAuditLogLevel(logLevel)\n              .init();\n</code></pre>"},{"location":"standards/coding-standards/#braces","title":"Braces","text":"<ul> <li>Opening braces should be on the same line as the declaration</li> <li>Closing braces should be on their own line</li> <li>Always use braces for control statements, even for single-line blocks</li> </ul> <p>Example:</p> <pre><code>// Good - braces on same line as declaration\nif (condition) {\n    doSomething();\n} else {\n    doSomethingElse();\n}\n\n// Bad - missing braces for single-line block\nif (condition)\n    doSomething();\n</code></pre>"},{"location":"standards/coding-standards/#whitespace","title":"Whitespace","text":"<ul> <li>Use a space after control keywords (if, for, while, etc.)</li> <li>Use spaces around operators</li> <li>No space between method name and opening parenthesis</li> <li>No space after opening parenthesis or before closing parenthesis</li> </ul> <p>Example:</p> <pre><code>// Good - proper whitespace\nfor (int i = 0; i &lt; 10; i++) {\n    doSomething(i);\n}\n\n// Bad - improper whitespace\nfor(int i=0;i&lt;10;i++){\n    doSomething (i);\n}\n</code></pre>"},{"location":"standards/coding-standards/#naming-conventions","title":"Naming Conventions","text":""},{"location":"standards/coding-standards/#packages","title":"Packages","text":"<ul> <li>Package names should be all lowercase</li> <li>Use reverse domain name notation (com.fluxtion.server)</li> <li>Use meaningful and descriptive package names</li> </ul> <p>Example: <pre><code>com.fluxtion.server.dispatch\ncom.fluxtion.server.config\ncom.fluxtion.server.service.admin\n</code></pre></p>"},{"location":"standards/coding-standards/#classes-and-interfaces","title":"Classes and Interfaces","text":"<ul> <li>Class and interface names should be nouns in UpperCamelCase</li> <li>Interface names should not start with 'I'</li> <li>Abstract classes may start with 'Abstract'</li> </ul> <p>Example: <pre><code>public class EventProcessor { }\npublic interface EventSource { }\npublic abstract class AbstractEventSourceService { }\n</code></pre></p>"},{"location":"standards/coding-standards/#methods","title":"Methods","text":"<ul> <li>Method names should be verbs in lowerCamelCase</li> <li>Methods that return boolean should start with 'is', 'has', or similar</li> </ul> <p>Example: <pre><code>public void processEvent(Object event) { }\npublic boolean isProcessorRegistered(String name) { }\n</code></pre></p>"},{"location":"standards/coding-standards/#variables-and-fields","title":"Variables and Fields","text":"<ul> <li>Variable and field names should be in lowerCamelCase</li> <li>Constants should be in UPPER_SNAKE_CASE</li> <li>Field names should be descriptive and avoid abbreviations</li> </ul> <p>Example: <pre><code>private final EventFlowManager flowManager;\nprivate static final String CONFIG_FILE_PROPERTY = \"fluxtionserver.config.file\";\n</code></pre></p>"},{"location":"standards/coding-standards/#generics","title":"Generics","text":"<ul> <li>Type parameters should be single uppercase letters or descriptive names in UpperCamelCase</li> <li>Common type parameters:</li> <li>T for a general type</li> <li>E for element type</li> <li>K for key type</li> <li>V for value type</li> </ul> <p>Example: <pre><code>public class EventProcessorConfig&lt;T extends EventProcessor&lt;?&gt;&gt; { }\npublic interface EventSource&lt;T&gt; { }\n</code></pre></p>"},{"location":"standards/coding-standards/#documentation-standards","title":"Documentation Standards","text":""},{"location":"standards/coding-standards/#file-headers","title":"File Headers","text":"<p>All source files should include the SPDX license header:</p> <pre><code>/*\n * SPDX-FileCopyrightText: \u00a9 2025 Gregory Higgins &lt;greg.higgins@v12technology.com&gt;\n * SPDX-License-Identifier: AGPL-3.0-only\n */\n</code></pre>"},{"location":"standards/coding-standards/#javadoc","title":"Javadoc","text":"<ul> <li>All public classes, interfaces, and methods should have Javadoc</li> <li>Javadoc should describe what the class/method does, not how it does it</li> <li>Use <code>@param</code>, <code>@return</code>, <code>@throws</code> tags as appropriate</li> <li>Link to related classes using <code>{@link ClassName}</code></li> </ul> <p>Example:</p> <pre><code>/**\n * Publishes events to {@link EventToQueuePublisher}. Register an {@link EventSource} instance with {@link EventFlowManager}\n * to receive the target queue via the setEventToQueuePublisher callback method.\n *\n * @param &lt;T&gt; the type of events published by this source\n */\npublic interface EventSource&lt;T&gt; {\n    /**\n     * Subscribes to events from this source.\n     *\n     * @param eventSourceKey the subscription key\n     */\n    void subscribe(EventSubscriptionKey&lt;T&gt; eventSourceKey);\n}\n</code></pre>"},{"location":"standards/coding-standards/#comments","title":"Comments","text":"<ul> <li>Use comments to explain why, not what</li> <li>Use TODO comments for code that needs to be completed</li> <li>Avoid commented-out code</li> </ul> <p>Example:</p> <pre><code>// Good - explains why\n// Use a concurrent map to handle multiple threads accessing the services\nprivate final ConcurrentHashMap&lt;String, Service&lt;?&gt;&gt; registeredServices = new ConcurrentHashMap&lt;&gt;();\n\n// Bad - explains what, which is already clear from the code\n// Create a new map\nMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n</code></pre>"},{"location":"standards/coding-standards/#error-handling","title":"Error Handling","text":""},{"location":"standards/coding-standards/#exceptions","title":"Exceptions","text":"<ul> <li>Use checked exceptions for recoverable errors</li> <li>Use unchecked exceptions for programming errors</li> <li>Create custom exceptions for specific error cases</li> <li>Always include meaningful error messages</li> </ul> <p>Example:</p> <pre><code>// Good - specific exception with meaningful message\nthrow new IllegalArgumentException(\"cannot register service name is already assigned:\" + serviceName);\n\n// Good - using Objects.requireNonNull for parameter validation\nObjects.requireNonNull(eventSourceKey, \"eventSourceKey must be non-null\");\n</code></pre>"},{"location":"standards/coding-standards/#null-handling","title":"Null Handling","text":"<ul> <li>Use <code>Objects.requireNonNull</code> to validate parameters</li> <li>Use Optional for values that might be absent</li> <li>Avoid returning null from methods when possible</li> </ul> <p>Example:</p> <pre><code>// Good - null validation\npublic void registerEventSource(String sourceName, EventSource&lt;T&gt; eventSource) {\n    Objects.requireNonNull(eventSource, \"eventSource must be non-null\");\n    // Implementation\n}\n\n// Good - using Optional\npublic Optional&lt;Service&lt;?&gt;&gt; findService(String name) {\n    return Optional.ofNullable(registeredServices.get(name));\n}\n</code></pre>"},{"location":"standards/coding-standards/#resource-management","title":"Resource Management","text":"<ul> <li>Use try-with-resources for automatic resource cleanup</li> <li>Close resources in finally blocks if try-with-resources is not applicable</li> </ul> <p>Example:</p> <pre><code>// Good - try-with-resources\ntry (FileReader reader = new FileReader(configFileName)) {\n    return bootServer(reader, logRecordListener);\n}\n</code></pre>"},{"location":"standards/coding-standards/#logging","title":"Logging","text":""},{"location":"standards/coding-standards/#log-levels","title":"Log Levels","text":"<ul> <li>ERROR: Severe errors that cause the application to malfunction</li> <li>WARNING: Potential issues that don't prevent the application from working</li> <li>INFO: Important runtime events (startup, shutdown, configuration)</li> <li>DEBUG: Detailed information for debugging</li> <li>TRACE: Very detailed information for troubleshooting</li> </ul>"},{"location":"standards/coding-standards/#logging-practices","title":"Logging Practices","text":"<ul> <li>Use the appropriate log level</li> <li>Include relevant context in log messages</li> <li>Use parameterized logging to avoid string concatenation</li> <li>Log exceptions with their stack traces</li> </ul> <p>Example:</p> <pre><code>// Good - appropriate log level with context\nlog.info(\"registerEventSource name:\" + sourceName + \" eventSource:\" + eventSource);\n\n// Good - logging exception with stack trace\nlog.warning(\"could not add eventProcessor:\" + name + \" to group:\" + groupName + \" error:\" + e.getMessage());\n</code></pre>"},{"location":"standards/coding-standards/#structured-logging","title":"Structured Logging","text":"<ul> <li>Use structured logging for machine-readable logs</li> <li>Include key-value pairs in log messages</li> </ul> <p>Example:</p> <pre><code>// Good - structured logging\nlog.info(\"Starting event processor group: '\" + groupName + \"' for running server\");\n</code></pre>"},{"location":"standards/coding-standards/#testing","title":"Testing","text":""},{"location":"standards/coding-standards/#test-structure","title":"Test Structure","text":"<ul> <li>Use JUnit 5 for testing</li> <li>Follow the Arrange-Act-Assert pattern</li> <li>One test method should test one scenario</li> <li>Test methods should have descriptive names</li> </ul> <p>Example:</p> <pre><code>@Test\npublic void testPublish() {\n    // Arrange\n    EventToQueuePublisher&lt;String&gt; eventToQueue = new EventToQueuePublisher&lt;&gt;(\"myQueue\");\n    eventToQueue.setCacheEventLog(true);\n    ArrayList&lt;Object&gt; actual = new ArrayList&lt;&gt;();\n    OneToOneConcurrentArrayQueue&lt;Object&gt; targetQueue = new OneToOneConcurrentArrayQueue&lt;&gt;(100);\n    eventToQueue.addTargetQueue(targetQueue, \"outputQueue\");\n\n    // Act\n    eventToQueue.publish(\"A\");\n    targetQueue.drainTo(actual, 100);\n\n    // Assert\n    Assertions.assertIterableEquals(List.of(\"A\"), actual);\n}\n</code></pre>"},{"location":"standards/coding-standards/#test-coverage","title":"Test Coverage","text":"<ul> <li>Aim for high test coverage (&gt;80%)</li> <li>Test both positive and negative scenarios</li> <li>Test edge cases and boundary conditions</li> <li>Use mocks for external dependencies</li> </ul>"},{"location":"standards/coding-standards/#test-organization","title":"Test Organization","text":"<ul> <li>Test classes should mirror the structure of the main code</li> <li>Test classes should be named with the class they test plus \"Test\"</li> <li>Group related tests in nested classes</li> </ul> <p>Example: <pre><code>src/main/java/com/fluxtion/server/dispatch/EventToQueuePublisher.java\nsrc/test/java/com/fluxtion/server/dispatch/EventToQueuePublisherTest.java\n</code></pre></p>"},{"location":"standards/coding-standards/#performance-considerations","title":"Performance Considerations","text":""},{"location":"standards/coding-standards/#memory-management","title":"Memory Management","text":"<ul> <li>Minimize object creation in performance-critical paths</li> <li>Use primitive types instead of boxed types when possible</li> <li>Be careful with string concatenation in loops</li> <li>Consider using object pools for frequently created objects</li> </ul>"},{"location":"standards/coding-standards/#concurrency","title":"Concurrency","text":"<ul> <li>Use thread-safe collections for shared data</li> <li>Prefer immutable objects for thread safety</li> <li>Use explicit locks only when necessary</li> <li>Consider using concurrent data structures from java.util.concurrent</li> </ul> <p>Example:</p> <pre><code>// Good - using concurrent collections for thread safety\nprivate final ConcurrentHashMap&lt;String, Service&lt;?&gt;&gt; registeredServices = new ConcurrentHashMap&lt;&gt;();\nprivate final Set&lt;Service&lt;?&gt;&gt; registeredAgentServices = ConcurrentHashMap.newKeySet();\n</code></pre>"},{"location":"standards/coding-standards/#resource-usage","title":"Resource Usage","text":"<ul> <li>Close resources properly (connections, files, etc.)</li> <li>Use try-with-resources for automatic resource cleanup</li> <li>Release resources in the reverse order of acquisition</li> </ul>"},{"location":"standards/coding-standards/#optimization","title":"Optimization","text":"<ul> <li>Optimize only after profiling</li> <li>Document performance-critical code</li> <li>Consider time and space complexity of algorithms</li> </ul>"},{"location":"standards/coding-standards/#security-best-practices","title":"Security Best Practices","text":""},{"location":"standards/coding-standards/#input-validation","title":"Input Validation","text":"<ul> <li>Validate all input from external sources</li> <li>Use parameterized queries for database access</li> <li>Sanitize data before using it in logs or output</li> </ul> <p>Example:</p> <pre><code>// Good - input validation\nObjects.requireNonNull(configFileName, \"fluxtion config file must be specified by system property: \" + CONFIG_FILE_PROPERTY);\n</code></pre>"},{"location":"standards/coding-standards/#authentication-and-authorization","title":"Authentication and Authorization","text":"<ul> <li>Use proper authentication mechanisms</li> <li>Implement role-based access control</li> <li>Validate permissions before performing sensitive operations</li> </ul>"},{"location":"standards/coding-standards/#secure-configuration","title":"Secure Configuration","text":"<ul> <li>Don't hardcode sensitive information</li> <li>Use environment variables or secure vaults for secrets</li> <li>Validate configuration before use</li> </ul>"},{"location":"standards/coding-standards/#secure-communication","title":"Secure Communication","text":"<ul> <li>Use TLS for network communication</li> <li>Validate certificates</li> <li>Use secure protocols and cipher suites</li> </ul>"},{"location":"standards/coding-standards/#code-organization","title":"Code Organization","text":""},{"location":"standards/coding-standards/#package-structure","title":"Package Structure","text":"<ul> <li>Organize packages by feature or layer</li> <li>Keep related classes together</li> <li>Use subpackages for specialized functionality</li> </ul> <p>Example: <pre><code>com.fluxtion.server.config - Configuration-related classes\ncom.fluxtion.server.dispatch - Event dispatching classes\ncom.fluxtion.server.service - Service-related classes\ncom.fluxtion.server.service.admin - Administration services\n</code></pre></p>"},{"location":"standards/coding-standards/#class-structure","title":"Class Structure","text":"<ul> <li>One class per file</li> <li>Keep classes focused on a single responsibility</li> <li>Extract common functionality to base classes or utilities</li> <li>Use composition over inheritance</li> </ul>"},{"location":"standards/coding-standards/#interface-design","title":"Interface Design","text":"<ul> <li>Design interfaces for consumers, not implementers</li> <li>Keep interfaces focused and cohesive</li> <li>Use default methods for backward compatibility</li> </ul> <p>Example:</p> <pre><code>// Good - focused interface with clear purpose\npublic interface EventSource&lt;T&gt; {\n    void subscribe(EventSubscriptionKey&lt;T&gt; eventSourceKey);\n    void unSubscribe(EventSubscriptionKey&lt;T&gt; eventSourceKey);\n    void setEventToQueuePublisher(EventToQueuePublisher&lt;T&gt; targetQueue);\n\n    // Default methods for optional functionality\n    default void setEventWrapStrategy(EventWrapStrategy eventWrapStrategy) {\n    }\n}\n</code></pre>"},{"location":"standards/coding-standards/#code-reuse","title":"Code Reuse","text":"<ul> <li>Extract common code to utility classes</li> <li>Use composition to share behavior</li> <li>Consider using design patterns for common problems</li> </ul>"},{"location":"standards/coding-standards/#dependency-management","title":"Dependency Management","text":""},{"location":"standards/coding-standards/#external-dependencies","title":"External Dependencies","text":"<ul> <li>Minimize external dependencies</li> <li>Use well-maintained libraries</li> <li>Keep dependencies up to date</li> <li>Document why dependencies are needed</li> </ul>"},{"location":"standards/coding-standards/#internal-dependencies","title":"Internal Dependencies","text":"<ul> <li>Minimize coupling between components</li> <li>Use dependency injection</li> <li>Design for testability</li> <li>Use interfaces to decouple implementation details</li> </ul> <p>Example:</p> <pre><code>// Good - dependency injection through constructor\npublic AbstractEventSourceService(\n        String name,\n        CallBackType eventToInvokeType,\n        Supplier&lt;EventToInvokeStrategy&gt; eventToInokeStrategySupplier) {\n    this.name = name;\n    this.eventToInvokeType = eventToInvokeType;\n    this.eventToInokeStrategySupplier = eventToInokeStrategySupplier;\n}\n\n// Good - dependency injection through method\n@ServiceRegistered\npublic void scheduler(SchedulerService scheduler) {\n    this.scheduler = scheduler;\n}\n</code></pre>"},{"location":"standards/coding-standards/#version-management","title":"Version Management","text":"<ul> <li>Use semantic versioning</li> <li>Document breaking changes</li> <li>Provide migration guides for major version changes</li> </ul>"}]}